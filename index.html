<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Tank Game</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Audiowide', 'Arial', sans-serif;
            background: #000;
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%;
        }
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }
        #game-ui {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            max-width: 90vw; /* Prevent controls from flowing off screen */
            font-family: 'Audiowide', sans-serif;
        }
        .control-row {
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            justify-content: flex-start; /* Left align in desktop mode */
            height: 40px; /* Fixed height for consistent spacing */
        }
        .control-label {
            width: 120px;
            text-shadow: 0 0 5px #00ffff;
            font-size: 16px;
            text-align: right;
            padding-right: 15px;
        }
        .angle-hint {
            font-size: 12px;
            opacity: 0.8;
            color: #aaffff;
        }
        input[type="range"] {
            width: 220px;
            -webkit-appearance: none;
            height: 12px; /* Increased height for better touch */
            background: linear-gradient(90deg, #001f3f, #00ffff);
            border-radius: 10px;
            cursor: pointer;
            touch-action: none; /* Prevents scrolling while using sliders */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px; /* Larger thumb for touch */
            height: 24px; /* Larger thumb for touch */
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px #00ffff;
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px; /* Larger thumb for touch */
            height: 24px; /* Larger thumb for touch */
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px #00ffff;
            border: none;
        }
        button {
            background: linear-gradient(to bottom, #006F82, #00404D);
            border: none;
            color: white;
            padding: 15px 20px; /* Larger padding for better touch targets */
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            text-shadow: 0 0 5px #00ffff;
            font-size: 16px; /* Larger font for better visibility */
            min-width: 160px; /* Ensure minimum width for touch */
        }
        button:hover {
            background: linear-gradient(to bottom, #008FAA, #006F82);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        button:disabled {
            background: #333;
            cursor: not-allowed;
            border: 1px solid #555;
            box-shadow: none;
        }
        #math-question {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            color: white;
            width: 350px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }
        #math-question h3 {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            font-size: 28px;
            margin-top: 0;
        }
        #math-question p {
            font-size: 24px;
            margin: 20px 0;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }
        #math-question input {
            margin-top: 20px;
            padding: 15px; /* Increased padding for better touch area */
            width: 100px;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid #00ffff;
            border-radius: 5px;
            color: white;
            font-size: 28px; /* Larger font size for better visibility */
            font-weight: bold;
        }
        #result-message {
            height: 20px;
            color: white;
            text-align: center;
            font-weight: bold;
            margin-top: 10px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        .score-display {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: white;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        .score-container {
            display: flex;
            gap: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 30px;
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        .player-health, .computer-health {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .health-bar-container {
            width: 200px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .player-health-bar, .computer-health-bar {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
        }
        .player-health-bar {
            background: linear-gradient(to right, #00ff00, #007700);
        }
        .computer-health-bar {
            background: linear-gradient(to right, #ff3333, #aa0000);
        }
        .health-text {
            font-size: 14px;
            margin-top: 5px;
        }
        .player-health .title {
            color: #00aaff;
        }
        .computer-health .title {
            color: #ff3b3b;
        }
        
        /* Media queries for responsive design */
        @media (max-width: 768px) {
            .control-row {
                gap: 10px;
                margin-bottom: 10px;
                justify-content: center; /* Center items when on mobile */
                height: auto; /* Allow flexible height on mobile */
            }
            
            .control-label {
                width: 80px;
                font-size: 14px;
                text-align: left;
                padding-right: 0;
            }
            
            input[type="range"] {
                width: 140px;
            }
            
            button {
                width: 100%; /* Full width buttons on mobile */
                padding: 16px 10px;
            }
            
            #game-ui {
                padding: 15px;
                gap: 5px;
            }
            
            #angle-value, #direction-value, #power-value {
                width: auto;
                font-size: 18px;
                margin-left: 10px;
            }
        }

        @media (max-width: 480px) {
            .score-container {
                gap: 20px;
                padding: 8px 15px;
            }
            
            .health-bar-container {
                width: 120px;
            }
            
            input[type="range"] {
                width: 120px;
            }
            
            #math-question {
                width: 90%;
                padding: 20px;
            }
            
            #math-question h3 {
                font-size: 22px;
            }
            
            #math-question p {
                font-size: 20px;
            }
            
            /* Adjust control values display */
            #angle-value, #direction-value, #power-value {
                min-width: 40px;
                text-align: center;
            }
        }

        #angle-value, #direction-value, #power-value {
            width: 60px;
            text-align: center;
            font-weight: bold;
            font-size: 24px;
            color: #00ffff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.7);
            margin-left: 15px;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Score Display -->
    <div class="score-display">
        <div class="score-container">
            <div class="player-health">
                <div class="title">YOU</div>
                <div class="health-bar-container">
                    <div class="player-health-bar" id="player-health-bar"></div>
                </div>
                <div class="health-text" id="player-health-text">100%</div>
            </div>
            <div class="computer-health">
                <div class="title">CPU</div>
                <div class="health-bar-container">
                    <div class="computer-health-bar" id="computer-health-bar"></div>
                </div>
                <div class="health-text" id="computer-health-text">100%</div>
            </div>
        </div>
    </div>

    <!-- Math question modal -->
    <div id="math-question">
        <h3>Answer to fire!</h3>
        <p id="question-text">What is 5 + 3?</p>
        <input type="number" id="answer-input">
        <p><button id="submit-answer">Submit</button></p>
    </div>

    <!-- Game UI -->
    <div id="ui-container">
        <div id="game-ui">
            <div class="control-row">
                <span class="control-label">Angle:</span>
                <input type="range" id="angle-control" min="0" max="90" value="45">
                <span id="angle-value">45°</span>
            </div>
            <div class="control-row">
                <span class="control-label">Direction:</span>
                <input type="range" id="direction-control" min="-45" max="45" value="0">
                <span id="direction-value">0°</span>
            </div>
            <div class="control-row">
                <span class="control-label">Power:</span>
                <input type="range" id="power-control" min="10" max="100" value="50">
                <span id="power-value">50%</span>
            </div>
            <div class="control-row">
                <button id="fire-button">Answer Math & Fire!</button>
            </div>
            <div id="result-message"></div>
        </div>
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/TextureLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/CubeTextureLoader.js"></script>
    
    <script>
        // Game variables
        let scene, camera, renderer, controls;
        let terrain, playerTank, computerTank;
        let cannonball = null;
        let playerTurn = true;
        let gameActive = true;
        
        // Physics variables
        const gravity = 9.8;
        let cannonballVelocity = { x: 0, y: 0, z: 0 };
        
        // Game state
        let destructionMap = [];
        
        // Tank health instead of score (replaced playerScore and computerScore)
        const MAX_HEALTH = 100;
        let playerHealth = MAX_HEALTH;
        let computerHealth = MAX_HEALTH;
        
        // Particle system containers
        let explosionGroups = [];
        let smokeParticles = [];
        
        // Powerup variables
        let consecutiveCorrectAnswers = 0;
        let playerHasTripleShot = false;
        let playerHasShield = false;
        let tripleShotUsed = false;
        let currentShot = 0;
        let totalTripleShotBalls = 3;
        let waitingForTripleShot = false;  // Flag to track if we're waiting for a triple shot cannonball to finish
        let tripleShotAngles = [-5, 0, 5]; // Angle offsets for triple shot
        let nextPowerUp = "tripleshot";    // Track which power-up is next (alternates between "tripleshot" and "shield")
        const POWERUP_THRESHOLD = 3;       // Number of correct answers needed for a power-up
        
        // Initialize the game
        initGame();
        animate();
        
        function initGame() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 9, 15); // Moved back and higher to view the extended terrain
            
            // Create renderer with antialiasing and better shadows
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Add controls for development purposes
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Add skybox
            createSkybox();
            
            // Add lighting with dramatic effect
            addLighting();
            
            // Create terrain
            createTerrain();
            
            // Add environment objects (trees and boulders)
            createEnvironmentObjects();
            
            // Create tanks
            createTanks();
            
            // Set up event listeners
            setupEventListeners();
            
            // Force initial shadow map update
            forceShadowMapUpdate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function createSkybox() {
            // Set a simple sky blue background color instead of loading cube textures
            scene.background = new THREE.Color(0x87CEEB);
            
            // Adjust the fog color to match the sky blue background
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.02);
        }
        
        function addLighting() {
            // Add dramatic lighting

            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x333333, 0.4);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const mainLight = new THREE.DirectionalLight(0xffffcc, 1.2);
            mainLight.position.set(10, 20, 15); // Higher and positioned to cast longer shadows
            mainLight.castShadow = true;
            
            // Improve shadow quality
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -25; // Expanded from -20 to -25
            mainLight.shadow.camera.right = 25; // Expanded from 20 to 25
            mainLight.shadow.camera.top = 25;   // Expanded from 20 to 25
            mainLight.shadow.camera.bottom = -25; // Expanded from -20 to -25
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.bias = -0.001; // Adjusted bias to reduce shadow acne
            
            // Create a target object for the directional light
            const lightTarget = new THREE.Object3D();
            lightTarget.position.set(0, 0, 0); // Center of the scene
            scene.add(lightTarget);
            mainLight.target = lightTarget;
            
            scene.add(mainLight);
            
            // Add a blue backlight for dramatic effect
            const backLight = new THREE.DirectionalLight(0x0077ff, 0.5);
            backLight.position.set(-10, 10, -10);
            scene.add(backLight);
            
            // Add a subtle ground light for better terrain visibility
            const groundLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(groundLight);
        }
        
        function createTerrain() {
            // Create terrain geometry with more detail - extended by 8 units on each side (30 -> 46)
            const terrainGeometry = new THREE.PlaneGeometry(46, 15, 192, 64);
            terrainGeometry.rotateX(-Math.PI / 2);
            
            // Create height map for terrain with more dramatic hills
            const vertices = terrainGeometry.attributes.position.array;
            
            // Clear any previous destruction map - we don't need it anymore
            destructionMap = [];
            
            // Generate random offsets and frequencies for each game
            // These will control the randomness of the terrain
            const randomSeed1 = Math.random() * 10;
            const randomSeed2 = Math.random() * 10;
            const randomSeed3 = Math.random() * 10;
            const randomSeed4 = Math.random() * 10;
            
            // Random frequency multipliers (between 0.8 and 1.2 of original values)
            const freqMultiplier1 = 0.8 + Math.random() * 0.4;
            const freqMultiplier2 = 0.8 + Math.random() * 0.4;
            const freqMultiplier3 = 0.8 + Math.random() * 0.4;
            const freqMultiplier4 = 0.8 + Math.random() * 0.4;
            
            // Random amplitude multipliers
            const ampMultiplier1 = 0.9 + Math.random() * 0.6; // 0.9-1.5 range
            const ampMultiplier2 = 0.9 + Math.random() * 0.6;
            const ampMultiplier3 = 0.9 + Math.random() * 0.6;
            const ampMultiplier4 = 0.9 + Math.random() * 0.6;
            
            // Randomize central hill parameters
            const hillAmplitude = 3.0 + Math.random() * 1.0;  // 3.0 to 4.0 (was fixed at 3.5)
            const hillWidth = 5.0 + Math.random() * 2.0;      // 5.0 to 7.0 (was fixed at 6.0)
            
            // Random horizontal shift for the hill (slight shift to make it off-center)
            const hillCenter = (Math.random() - 0.5) * 2; // -1 to 1 range
            
            // Calculate baseline heights for the terrain
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                
                // Create more dramatic terrain with multiple frequencies - RANDOMIZED VALUES
                let height = 
                    Math.sin((x / 3) * freqMultiplier1 + randomSeed1) * 1.2 * ampMultiplier1 +
                    Math.cos((z / 2) * freqMultiplier2 + randomSeed2) * 0.8 * ampMultiplier2 +
                    Math.sin((x / 1.5 + z / 2) * freqMultiplier3 + randomSeed3) * 0.6 * ampMultiplier3 +
                    Math.sin((x * 0.5 + z * 0.5) * freqMultiplier4 + randomSeed4) * 0.7 * ampMultiplier4;
                
                // Create a more pronounced hill in the middle (centered at x=hillCenter)
                // Using a Gaussian function for a natural slope
                const distanceFromCenter = x - hillCenter;
                
                // Create a bell-shaped hill that's tallest in the middle
                // and gradually tapers off as we move away from the center
                const hillHeight = hillAmplitude * Math.exp(-(distanceFromCenter * distanceFromCenter) / (2 * hillWidth * hillWidth));
                height += hillHeight;
                
                // Apply a slight overall gradient to ensure the tanks are at similar heights
                // This counters any systematic height differences between the sides
                const sideBalance = -0.05 * x; // Slight downward slope from left to right
                height += sideBalance;
                
                vertices[i + 1] = height;
            }
            
            // Load a texture for the terrain
            const textureLoader = new THREE.TextureLoader();
            const grassTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg');
            
            // Create terrain material with textures
            const terrainMaterial = new THREE.MeshStandardMaterial({
                map: grassTexture,
                roughness: 0.8,
                metalness: 0.1,
                bumpMap: grassTexture,
                bumpScale: 0.1,
            });
            
            // Repeat the texture for better detail
            terrainMaterial.map.wrapS = terrainMaterial.map.wrapT = THREE.RepeatWrapping;
            terrainMaterial.map.repeat.set(12, 4); // Increased from 8 to 12 to match the wider terrain
            
            // Create terrain mesh
            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.receiveShadow = true;
            terrain.castShadow = true;  // Add this line to enable self-shadowing
            terrain.name = "terrain";
            scene.add(terrain);
        }
        
        function createTanks() {
            // Create player tank (blue) on left, facing right (towards +X)
            playerTank = createTank(0x0066ff, -12, getTerrainHeightAt(-12, 0) + 0.5, 0);
            playerTank.name = "playerTank";
            playerTank.userData.health = MAX_HEALTH; // Initialize health property
            playerTank.userData.isPlayer = true;
            scene.add(playerTank);
            
            // Create computer tank (red) on right, facing left (towards -X)
            computerTank = createTank(0xff3333, 12, getTerrainHeightAt(12, 0) + 0.5, Math.PI);
            computerTank.name = "computerTank";
            computerTank.userData.health = MAX_HEALTH; // Initialize health property
            computerTank.userData.isPlayer = false;
            scene.add(computerTank);
            
            // Initialize tank velocities to zero
            playerTank.userData.velocity = 0;
            computerTank.userData.velocity = 0;
            
            // Create health bars for each tank
            createHealthBar(playerTank);
            createHealthBar(computerTank);
            
            // Initialize UI health bars
            updateUIHealthBars();
            
            // Run tank gravity initially to ensure tanks are properly aligned with terrain
            // and have proper rotations based on the terrain slope
            setTimeout(() => {
                applyTankGravity(playerTank, 1/60);
                applyTankGravity(computerTank, 1/60);
            }, 100); // Small delay to ensure terrain is fully loaded
        }
        
        function createTank(color, x, y, rotation) {
            const tank = new THREE.Group();
            
            // Tank body - more detailed
            const bodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 1.2); 
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.5,
                metalness: 0.7,
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            tank.add(body);
            
            // Tank tracks - add detail
            const trackGeometry = new THREE.BoxGeometry(2, 0.2, 1.4);
            const trackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.8,
                metalness: 0.2
            });
            const tracks = new THREE.Mesh(trackGeometry, trackMaterial);
            tracks.position.y = -0.35;
            tracks.castShadow = true;
            tracks.receiveShadow = true;
            tank.add(tracks);
            
            // Tank turret - more detailed
            const turretGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.4, 8);
            const turret = new THREE.Mesh(turretGeometry, bodyMaterial);
            turret.position.set(0, 0.5, 0);
            turret.castShadow = true;
            turret.receiveShadow = true;
            tank.add(turret);
            
            // Tank hatch on turret
            const hatchGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
            const hatch = new THREE.Mesh(hatchGeometry, trackMaterial);
            hatch.position.set(0, 0.7, 0);
            hatch.castShadow = true;
            tank.add(hatch);
            
            // Tank cannon - simplified design without muzzle
            // Create a cylinder that's already aligned along the X-axis
            // We'll rotate this cylinder from its default orientation (Y-axis) to the X-axis
            const cannonGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.2, 16);
            const cannonMaterial = new THREE.MeshStandardMaterial({ 
                color: color, // Use the same color as the tank body instead of 0x222222
                roughness: 0.4,
                metalness: 0.8 
            });
            const cannon = new THREE.Mesh(cannonGeometry, cannonMaterial);
            
            // Rotate the cannon's default orientation to be along the X axis
            // By default cylinders in Three.js point along the Y axis
            cannon.rotation.z = Math.PI / 2; // Rotate 90 degrees to align with X axis
            
            // For player tank (facing right/+X)
            if (rotation === 0) {
                // Position cannon on the right side of turret with slight right offset
                cannon.position.set(0, 0, 0.2);
                
                // Set default angle to 45 degrees (same as UI default)
                // Since we've pre-rotated the cannon to align with X axis,
                // we now apply the angle from that starting position
                cannon.rotation.z = Math.PI / 2 + THREE.MathUtils.degToRad(45);
            } 
            // For computer tank (facing left/-X)
            else {
                // Position cannon on the left side of turret with slight left offset
                // Align with the base position used in updateCannons
                cannon.position.set(0.8, 0.8, -0.2);
                
                // For computer tank, we need to rotate in the opposite direction
                // PI/2 for initial X alignment, then PI to face left, then the angle
                cannon.rotation.z = Math.PI / 2 + Math.PI - THREE.MathUtils.degToRad(30);
            }
            
            cannon.castShadow = true;
            cannon.receiveShadow = true;
            tank.userData.cannon = cannon;
            tank.add(cannon);
            
            // Position tank
            tank.position.set(x, y, 0);
            
            return tank;
        }
        
        function getTerrainHeightAt(x, z) {
            // Raycasting to find the height of terrain at a given point
            if (!terrain) return 0; // Add safety check for terrain
            
            const raycaster = new THREE.Raycaster();
            raycaster.set(
                new THREE.Vector3(x, 10, z),
                new THREE.Vector3(0, -1, 0)
            );
            
            const intersects = raycaster.intersectObject(terrain);
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            
            return 0;
        }
        
        function setupEventListeners() {
            // Set up event listeners for controls
            document.getElementById('angle-control').addEventListener('input', function() {
                const angle = document.getElementById('angle-control').value;
                document.getElementById('angle-value').textContent = angle + '°';
                // The cannon angle is updated in the updateCannons function
            });
            
            document.getElementById('power-control').addEventListener('input', function() {
                const power = document.getElementById('power-control').value;
                document.getElementById('power-value').textContent = power;
            });
            
            // Add event listener for the direction control
            document.getElementById('direction-control').addEventListener('input', function() {
                const direction = document.getElementById('direction-control').value;
                document.getElementById('direction-value').textContent = direction + '°';
                
                // Update the tank's rotation based on the direction control
                if (playerTank) {
                    // Convert direction from degrees to radians for rotation
                    const directionRad = THREE.MathUtils.degToRad(-direction); // Negative because positive is right
                    playerTank.rotation.y = directionRad;
                    
                    // Make sure the tank stays on the terrain after rotation
                    const tankPosition = playerTank.position.clone();
                    const terrainHeight = getTerrainHeightAt(tankPosition.x, tankPosition.z);
                    playerTank.position.y = terrainHeight + 0.5; // 0.5 is the offset from the terrain
                }
            });
            
            document.getElementById('fire-button').addEventListener('click', function() {
                if (playerTurn && !cannonball) {
                    // Show math question first instead of firing directly
                    showMathQuestion();
                }
            });
            
            // Answer submission
            document.getElementById('submit-answer').addEventListener('click', function() {
                checkAnswer();
            });
            
            // Add event listener for Enter key to submit answers
            document.getElementById('answer-input').addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    checkAnswer();
                    event.preventDefault(); // Prevent default form submission
                }
            });
            
            // Add touch-specific enhancements for mobile
            addMobileTouchSupport();
            
            // Initialize the power-ups display
            updatePowerupsDisplay();
        }
        
        // New function to add mobile-specific touch support
        function addMobileTouchSupport() {
            // Prevent double-tap to zoom
            document.addEventListener('touchend', function(event) {
                if (event.target.tagName === 'BUTTON' || 
                    event.target.tagName === 'INPUT' || 
                    event.target.id === 'math-question') {
                    event.preventDefault();
                }
            }, { passive: false });
            
            // Prevent pinch zoom on game controls
            document.addEventListener('touchmove', function(event) {
                if (event.target.type === 'range' || 
                    event.target.tagName === 'BUTTON' || 
                    event.target.id === 'game-ui' ||
                    event.target.id === 'math-question') {
                    if (event.touches.length > 1) {
                        event.preventDefault();
                    }
                }
            }, { passive: false });
            
            // Make range inputs work better on touch devices
            const rangeInputs = document.querySelectorAll('input[type="range"]');
            rangeInputs.forEach(function(input) {
                // Add touch event handlers for better mobile experience
                input.addEventListener('touchstart', function(e) {
                    // Prevent screen from scrolling when adjusting sliders
                    e.preventDefault();
                    
                    // Update the value based on touch position
                    updateRangeFromTouch(e, this);
                }, { passive: false });
                
                input.addEventListener('touchmove', function(e) {
                    // Prevent screen from scrolling when adjusting sliders
                    e.preventDefault();
                    
                    // Update the value based on touch position
                    updateRangeFromTouch(e, this);
                }, { passive: false });
            });
            
            // Helper function to update range input value from touch position
            function updateRangeFromTouch(e, input) {
                const touch = e.touches[0];
                const rect = input.getBoundingClientRect();
                const width = rect.width;
                const x = touch.clientX - rect.left;
                
                // Calculate percentage
                let pct = x / width;
                if (pct < 0) pct = 0;
                if (pct > 1) pct = 1;
                
                // Calculate new value
                const min = parseInt(input.min || 0);
                const max = parseInt(input.max || 100);
                const newValue = min + (max - min) * pct;
                
                // Update input value
                input.value = Math.round(newValue);
                
                // Trigger input event to update display
                const event = new Event('input', {
                    bubbles: true,
                    cancelable: true,
                });
                input.dispatchEvent(event);
            }
            
            // Make math input field work better on mobile
            const answerInput = document.getElementById('answer-input');
            if (answerInput) {
                // Ensure numeric keyboard on mobile
                answerInput.inputMode = 'numeric';
                answerInput.pattern = '[0-9]*';
            }
        }
        
        function showMathQuestion() {
            // Generate a random math question suitable for 2nd graders
            const num1 = Math.floor(Math.random() * 10) + 1;
            const num2 = Math.floor(Math.random() * 10) + 1;
            const operationRand = Math.random();
            
            let question, answer;
            
            if (operationRand < 0.33) {
                // Addition
                question = `What is ${num1} + ${num2}?`;
                answer = num1 + num2;
            } else if (operationRand < 0.67) {
                // Subtraction (ensure positive result for 2nd graders)
                const larger = Math.max(num1, num2);
                const smaller = Math.min(num1, num2);
                question = `What is ${larger} - ${smaller}?`;
                answer = larger - smaller;
            } else {
                // Multiplication (keep it simple for 2nd graders)
                // Limit to smaller numbers for easier multiplication
                const smallNum1 = Math.floor(Math.random() * 5) + 1; // 1-5
                const smallNum2 = Math.floor(Math.random() * 5) + 1; // 1-5
                question = `What is ${smallNum1} × ${smallNum2}?`;
                answer = smallNum1 * smallNum2;
            }
            
            document.getElementById('question-text').textContent = question;
            document.getElementById('answer-input').value = '';
            document.getElementById('math-question').style.display = 'block';
            document.getElementById('answer-input').focus();
            
            // Store the answer for checking
            document.getElementById('math-question').dataset.answer = answer;
        }
        
        function checkAnswer() {
            const userAnswer = parseInt(document.getElementById('answer-input').value);
            const correctAnswer = parseInt(document.getElementById('math-question').dataset.answer);
            
            if (userAnswer === correctAnswer) {
                // Correct answer - track consecutive correct answers
                consecutiveCorrectAnswers++;
                
                // Check for powerups
                checkForPowerups();
                
                // Hide math question
                document.getElementById('math-question').style.display = 'none';
                
                // Show success message including streak if relevant
                let resultMessage = 'Correct! Firing cannon!';
                if (consecutiveCorrectAnswers > 1) {
                    resultMessage += ` (${consecutiveCorrectAnswers} correct in a row!)`;
                }
                
                document.getElementById('result-message').textContent = resultMessage;
                document.getElementById('result-message').style.color = '#4CAF50';
                
                // Fire the cannon
                if (playerHasTripleShot && !tripleShotUsed) {
                    tripleShotUsed = true;
                    currentShot = 0;
                    fireTripleShot();
                } else {
                    fireCannon();
                }
            } else {
                // Wrong answer - reset consecutive answers
                consecutiveCorrectAnswers = 0;
                updatePowerupsDisplay();
                
                document.getElementById('result-message').textContent = 'Wrong answer! Try again.';
                document.getElementById('result-message').style.color = '#FF0000';
                document.getElementById('answer-input').value = '';
                document.getElementById('answer-input').focus();
            }
        }
        
        // New function to check for and activate powerups
        function checkForPowerups() {
            // Check if we've reached the threshold for a power-up
            if (consecutiveCorrectAnswers >= POWERUP_THRESHOLD) {
                // Determine which power-up to activate based on the nextPowerUp variable
                if (nextPowerUp === "tripleshot") {
                    // Activate Triple Shot power-up
                    playerHasTripleShot = true;
                    tripleShotUsed = false;
                    
                    // Show powerup notification
                    showPowerupNotification("Triple Shot activated! Firing 3 cannonballs!");
                    
                    // Set next power-up to shield
                    nextPowerUp = "shield";
                } 
                else if (nextPowerUp === "shield") {
                    // Activate Shield power-up
                    playerHasShield = true;
                    
                    // Apply shield to player tank
                    applyShieldEffect(playerTank);
                    
                    // Show powerup notification
                    showPowerupNotification("Shield activated! You're protected from the next hit!");
                    
                    // Set next power-up to triple shot
                    nextPowerUp = "tripleshot";
                }
                
                // Reset consecutive correct answers after earning a power-up
                consecutiveCorrectAnswers = 0;
            }
            
            // Update UI to reflect powerups
            updatePowerupsDisplay();
        }

        // Function to show powerup notification
        function showPowerupNotification(message) {
            // Create notification element if it doesn't exist
            if (!document.getElementById('powerup-notification')) {
                const notification = document.createElement('div');
                notification.id = 'powerup-notification';
                notification.style.position = 'absolute';
                notification.style.top = '50%';
                notification.style.left = '50%';
                notification.style.transform = 'translate(-50%, -50%)';
                notification.style.background = 'rgba(0, 0, 0, 0.8)';
                notification.style.color = '#00ffff';
                notification.style.padding = '20px';
                notification.style.borderRadius = '10px';
                notification.style.textAlign = 'center';
                notification.style.fontSize = '24px';
                notification.style.fontWeight = 'bold';
                notification.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.5)';
                notification.style.zIndex = '1000';
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.5s';
                document.body.appendChild(notification);
            }
            
            const notification = document.getElementById('powerup-notification');
            notification.textContent = message;
            notification.style.opacity = '1';
            
            // Fade out notification after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 3000);
        }

        // Function to update powerups display in UI
        function updatePowerupsDisplay() {
            // Create powerup display if it doesn't exist
            if (!document.getElementById('powerups-display')) {
                const powerupsDisplay = document.createElement('div');
                powerupsDisplay.id = 'powerups-display';
                powerupsDisplay.style.position = 'absolute';
                powerupsDisplay.style.top = '120px';
                powerupsDisplay.style.left = '0';
                powerupsDisplay.style.width = '100%';
                powerupsDisplay.style.display = 'flex';
                powerupsDisplay.style.justifyContent = 'center';
                powerupsDisplay.style.pointerEvents = 'none';
                
                const powerupsContainer = document.createElement('div');
                powerupsContainer.style.background = 'rgba(0, 0, 0, 0.7)';
                powerupsContainer.style.padding = '10px 20px';
                powerupsContainer.style.borderRadius = '10px';
                powerupsContainer.style.display = 'flex';
                powerupsContainer.style.gap = '15px';
                powerupsContainer.style.border = '1px solid rgba(0, 255, 255, 0.3)';
                
                const streakDisplay = document.createElement('div');
                streakDisplay.id = 'streak-display';
                streakDisplay.style.color = '#FFFFFF';
                streakDisplay.textContent = 'Streak: 0/3';
                
                // Remove triple shot and shield indicators
                // Only add streak display to container
                powerupsContainer.appendChild(streakDisplay);
                powerupsDisplay.appendChild(powerupsContainer);
                
                document.body.appendChild(powerupsDisplay);
            }
            
            // Update the display
            if (document.getElementById('streak-display')) {
                // Show streak as X/3
                document.getElementById('streak-display').textContent = `Streak: ${consecutiveCorrectAnswers}/${POWERUP_THRESHOLD}`;
                
                // Change color if approaching a power-up
                if (consecutiveCorrectAnswers >= POWERUP_THRESHOLD - 1) {
                    document.getElementById('streak-display').style.color = '#00ffff';
                    document.getElementById('streak-display').style.textShadow = '0 0 5px rgba(0, 255, 255, 0.7)';
                } else {
                    document.getElementById('streak-display').style.color = '#FFFFFF';
                    document.getElementById('streak-display').style.textShadow = 'none';
                }
            }
            
            // Remove checks for triple shot and shield indicators as they no longer exist in the DOM
        }

        // Triple shot implementation
        function fireTripleShot() {
            // Initialize the triple shot sequence
            currentShot = 0;
            waitingForTripleShot = true;
            tripleShotUsed = true;
            
            // Show message about triple shot
            document.getElementById('result-message').textContent = `Triple Shot active! Firing shot 1 of ${totalTripleShotBalls}`;
            document.getElementById('result-message').style.color = '#00ffff';
            
            // Fire the first cannonball
            fireCannon(tripleShotAngles[currentShot]);
            
            // Increment the shot counter after firing
            currentShot++;
            
            // The rest will be handled in switchTurn when each cannonball completes
        }

        // Apply shield effect to tank
        function applyShieldEffect(tank) {
            // Create a shield mesh
            const shieldGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3
            });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.name = "shield";
            
            // Add the shield to the tank
            tank.add(shield);
            
            // Add a pulsating animation to the shield
            const startTime = Date.now();
            const animateShield = function() {
                if (!tank.getObjectByName("shield")) return; // Stop if shield is removed
                
                const elapsedTime = (Date.now() - startTime) / 1000;
                const scale = 1 + 0.1 * Math.sin(elapsedTime * 3);
                shield.scale.set(scale, scale, scale);
                
                requestAnimationFrame(animateShield);
            };
            
            animateShield();
        }

        // Modified fireCannon to support triple shot and horizontal direction
        function fireCannon(angleOffset = 0) {
            // Get angle and power
            let angle = parseFloat(document.getElementById('angle-control').value);
            const power = document.getElementById('power-control').value / 5;
            
            // Apply angle offset for triple shot
            angle += angleOffset;
            angle = Math.max(0, Math.min(90, angle)); // Keep within 0-90 range
            
            // Create cannonball with more detail
            const cannonballGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const cannonballMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.8
            });
            cannonball = new THREE.Mesh(cannonballGeometry, cannonballMaterial);
            cannonball.castShadow = true;
            
            // Position the cannonball at the end of the tank's cannon
            const tank = playerTurn ? playerTank : computerTank;
            
            // Get the world position of the cannon tip
            const cannonWorldPos = new THREE.Vector3();
            tank.userData.cannon.getWorldPosition(cannonWorldPos);
            
            // Get the direction vector from the cannon's rotation
            const verticalAngleRad = THREE.MathUtils.degToRad(angle);
            const direction = new THREE.Vector3(
                Math.cos(verticalAngleRad),
                Math.sin(verticalAngleRad),
                0
            );
            
            // Transform direction to world space (accounting for tank's rotation)
            const worldDirection = direction.clone();
            worldDirection.applyQuaternion(tank.quaternion);
            
            // Ensure z-component is zero when direction is 0 (for player tank)
            if (playerTurn && document.getElementById('direction-control').value == 0) {
                // If direction is 0, ensure the shot is perfectly straight by zeroing out z component
                worldDirection.z = 0;
                // Re-normalize to maintain consistent power
                worldDirection.normalize();
            } else {
                // Normal case - just normalize
                worldDirection.normalize();
            }
            
            // Calculate cannonball position at the end of the cannon
            // Since we've updated the cannon to pivot at the base, the muzzle is at the tip
            // The current cannon position is already adjusted for the rotation angle
            // So we don't need to add the length again - the cannonWorldPos is already at the end
            cannonball.position.copy(cannonWorldPos);
            scene.add(cannonball);
            
            // Set velocity based on direction and power
            cannonballVelocity = {
                x: worldDirection.x * power,
                y: worldDirection.y * power,
                z: worldDirection.z * power
            };
            
            // Create muzzle flash effect at cannon tip
            const muzzleFlashGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const muzzleFlashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 1
            });
            const muzzleFlash = new THREE.Mesh(muzzleFlashGeometry, muzzleFlashMaterial);
            muzzleFlash.position.copy(cannonWorldPos);
            scene.add(muzzleFlash);
            
            // Add a point light for the muzzle flash
            const flashLight = new THREE.PointLight(0xffff00, 2, 3);
            flashLight.position.copy(cannonWorldPos);
            scene.add(flashLight);
            
            // Fade out muzzle flash
            setTimeout(() => {
                scene.remove(muzzleFlash);
                scene.remove(flashLight);
            }, 100);
            
            // Create smoke effect from cannon
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const smokeGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 8, 8);
                    const smokeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x888888,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                    smoke.position.copy(cannonWorldPos);
                    smoke.position.x += (Math.random() - 0.5) * 0.2;
                    smoke.position.y += (Math.random() - 0.5) * 0.2;
                    smoke.position.z += (Math.random() - 0.5) * 0.2;
                    
                    smoke.userData = {
                        velocity: new THREE.Vector3(
                            worldDirection.x * (Math.random() * 0.5 + 0.5),
                            worldDirection.y * (Math.random() * 0.5 + 0.5) + Math.random() * 0.5,
                            worldDirection.z * (Math.random() * 0.5 + 0.5)
                        ),
                        rotationSpeed: (Math.random() - 0.5) * 0.01,
                        lifespan: 1 + Math.random(),
                        creationTime: Date.now()
                    };
                    
                    scene.add(smoke);
                    smokeParticles.push(smoke);
                }, i * 20);
            }
            
            // Create smoke ring effect
            createSmokeRing(cannonWorldPos, worldDirection);
            
            // Shake the camera - REMOVED to keep shake only on collisions
            // cameraShake(0.3, 300);
            
            // Disable controls during firing
            document.getElementById('fire-button').disabled = true;
        }
        
        function updateCannonball(deltaTime) {
            if (!cannonball) return;
            
            try {
                // Apply gravity
                cannonballVelocity.y -= gravity * deltaTime;
                
                // Make sure cannonball is still valid before updating position
                if (!cannonball || !cannonball.position) {
                    console.warn("Cannonball or its position became null");
                    resetCannonball();
                    return;
                }
                
                // Update position
                cannonball.position.x += cannonballVelocity.x * deltaTime;
                cannonball.position.y += cannonballVelocity.y * deltaTime;
                cannonball.position.z += cannonballVelocity.z * deltaTime;
                
                // Check again if cannonball is still valid after updating position
                if (!cannonball || !cannonball.position) {
                    console.warn("Cannonball or its position became null after position update");
                    resetCannonball();
                    return;
                }
                
                // Check for collision with terrain
                const terrainHeight = getTerrainHeightAt(cannonball.position.x, cannonball.position.z);
                
                if (cannonball && cannonball.position && cannonball.position.y <= terrainHeight) {
                    // Calculate impact speed (vertical component)
                    const impactSpeed = Math.abs(cannonballVelocity.y);
                    
                    // Check if impact is powerful enough to create a crater
                    if (impactSpeed > 2.0) {
                        // Handle full impact with terrain deformation
                        handleImpact();
                    } else {
                        // Low-speed impact - create a small bounce
                        // Reverse vertical velocity with damping for bounce effect
                        cannonballVelocity.y = -cannonballVelocity.y * 0.4; // 40% energy retained
                        
                        // Apply ground friction to horizontal velocity
                        cannonballVelocity.x *= 0.8;
                        cannonballVelocity.z *= 0.8;
                        
                        // Make sure the cannonball is above the terrain
                        cannonball.position.y = terrainHeight + 0.2;
                        
                        // Create a small dust effect for the bounce
                        createDenseSmoke(
                            cannonball.position.clone(),
                            5, // Fewer particles
                            0xAAAAAA, // Dust color
                            0.5 // Short duration
                        );
                        
                        // Check if this was a very low bounce (nearly stopped)
                        if (Math.abs(cannonballVelocity.y) < 1.0 && 
                            Math.sqrt(cannonballVelocity.x * cannonballVelocity.x + 
                                      cannonballVelocity.z * cannonballVelocity.z) < 1.0) {
                            // Ball has nearly stopped - end its movement
                            handleImpact();
                        }
                    }
                    return; // Exit early since impact is handled
                }
                
                // Make sure cannonball still exists before checking bounds
                if (!cannonball || !cannonball.position) return;
                
                // Check if cannonball is out of bounds
                if (
                    Math.abs(cannonball.position.x) > 23 ||  // Updated from 15 to 23 for the extended terrain
                    cannonball.position.y < -10 ||
                    Math.abs(cannonball.position.z) > 10
                ) {
                    resetCannonball();
                    switchTurn();
                    return; // Exit early since cannonball is now destroyed
                }
                
                // Check for collision with tanks
                if (cannonball && playerTank && computerTank) {
                    checkTankCollision();
                }
                
                // Check for collision with environment objects (boulders and trees)
                checkEnvironmentCollision();
                
            } catch (error) {
                console.error("Error in updateCannonball:", error);
                resetCannonball(); // Safety reset if something goes wrong
            }
        }
        
        function handleImpact() {
            // Create explosion with more dramatic effect
            createExplosion(cannonball.position.clone());
            
            // Modify terrain at impact point
            modifyTerrainAtImpact(cannonball.position.x, cannonball.position.z);
            
            // Camera shake on impact
            cameraShake(0.4, 500, false); // Keep camera controls enabled
            
            // Display message if we're in a triple shot sequence
            if (waitingForTripleShot) {
                const shotsRemaining = totalTripleShotBalls - currentShot;
                if (shotsRemaining > 0) {
                    document.getElementById('result-message').textContent = 
                        `Triple Shot: Shot ${currentShot} completed. ${shotsRemaining} more to go.`;
                    document.getElementById('result-message').style.color = '#00ffff';
                }
            }
            
            // Remove cannonball
            resetCannonball();
            
            // Switch turns (this will handle triple shot sequencing)
            switchTurn();
        }
        
        function createExplosion(position) {
            // Create explosion with more dramatic effect
            const particleCount = 50; // More particles
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            explosionGroup.userData.creationTime = Date.now();
            explosionGroup.userData.duration = 1.5; // Longer duration for better light fadeout
            
            // Create a point light for the explosion with a unique name for tracking
            const explosionLight = new THREE.PointLight(0xff7700, 5, 3);
            explosionLight.position.set(0, 0, 0);
            explosionLight.name = "explosionLight";
            explosionGroup.add(explosionLight);
            
            // Create a mesh for the core explosion
            const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 1
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            // Mark this mesh as the explosion core
            core.userData = { isCore: true };
            explosionGroup.add(core);
            
            // Create fire particles
            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 0.2 + 0.1;
                const particleGeometry = new THREE.SphereGeometry(size, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(
                        Math.random() * 0.2 + 0.8, // Red
                        Math.random() * 0.5,      // Green
                        Math.random() * 0.1       // Blue
                    ),
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random position within explosion radius
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = Math.random() * 0.8;
                
                particle.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                
                // Store velocity for animation
                particle.userData.velocity = particle.position.clone().normalize().multiplyScalar(Math.random() * 3 + 1);
                explosionGroup.add(particle);
            }
            
            // Add smoke particles that linger
            for (let i = 0; i < 20; i++) {
                const smokeGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const smokeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x555555,
                    transparent: true,
                    opacity: 0.7
                });
                
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                
                // Position smoke particles
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.3;
                smoke.position.set(
                    position.x + Math.cos(angle) * radius,
                    position.y + 0.3 + Math.random() * 0.5,
                    position.z + Math.sin(angle) * radius
                );
                
                // Store smoke properties
                smoke.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.5 + 0.5,
                        (Math.random() - 0.5) * 0.2
                    ),
                    rotationSpeed: (Math.random() - 0.5) * 0.01,
                    lifespan: 3 + Math.random() * 2,
                    creationTime: Date.now()
                };
                
                scene.add(smoke);
                smokeParticles.push(smoke);
            }
            
            scene.add(explosionGroup);
            explosionGroups.push(explosionGroup);
        }
        
        function modifyTerrainAtImpact(x, z) {
            // Create a dramatic crater at the impact point
            const impactRadius = 2.5; // Increased from 1.5 to 2.5 for larger craters
            const maxDepth = 0.8;     // Increased from 0.5 to 0.8 for deeper craters
            
            const terrainGeometry = terrain.geometry;
            const position = terrainGeometry.attributes.position;
            
            // Create more debris particles
            for (let i = 0; i < 25; i++) { // Increased from 15 to 25 debris pieces
                const debrisSize = Math.random() * 0.25 + 0.05; // Larger debris sizes
                const debrisGeometry = new THREE.BoxGeometry(
                    debrisSize,
                    debrisSize,
                    debrisSize
                );
                
                // Use varied colors for debris - mix of dirt and ground colors
                const colorVariation = Math.random();
                const debrisColor = colorVariation < 0.7 ? 
                    new THREE.Color(0x7e6a45) : // Dirt color (70% of debris)
                    new THREE.Color(0x4d8a3f);  // Grass color (30% of debris)
                
                const debrisMaterial = new THREE.MeshStandardMaterial({
                    color: debrisColor,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                
                // Position debris at impact point with wider spread
                debris.position.set(
                    x + (Math.random() - 0.5) * 2.0, // Wider horizontal spread
                    getTerrainHeightAt(x, z) + Math.random() * 1.0 + 0.2, // Higher vertical spread
                    z + (Math.random() - 0.5) * 2.0  // Wider depth spread
                );
                
                // Random rotation
                debris.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                // Set physics properties with more dramatic trajectories
                debris.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 5,     // Faster horizontal movement
                        Math.random() * 6 + 3,         // Higher vertical launch
                        (Math.random() - 0.5) * 5      // Faster z-axis movement
                    ),
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,   // Faster rotation
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    ),
                    lifespan: 2.5 + Math.random() * 1.5, // Longer lifespan
                    creationTime: Date.now(),
                    isWoodChunk: true // Flag for special handling in updateParticles
                };
                
                debris.castShadow = true;
                debris.receiveShadow = true;
                
                scene.add(debris);
                smokeParticles.push(debris);
            }
            
            // Add dust cloud at impact
            createDenseSmoke(
                new THREE.Vector3(x, getTerrainHeightAt(x, z) + 0.2, z), 
                15, // Number of particles
                0x8a7d5c, // Dust color
                3  // Duration
            );
            
            // Create a perfectly circular crater with a more dramatic edge
            for (let i = 0; i < position.count; i++) {
                const xPos = position.getX(i);
                const yPos = position.getY(i);
                const zPos = position.getZ(i);
                
                // Calculate exact distance from impact point to this vertex
                const dx = xPos - x;
                const dz = zPos - z;
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                // Only modify vertices within the impact radius (strict circle)
                if (distance <= impactRadius) {
                    // Calculate depth using a modified falloff function for a more dramatic crater
                    // This creates a crater with steeper edges and a flatter bottom
                    const t = distance / impactRadius;  // normalized distance (0 at center, 1 at edge)
                    
                    // Sharper edge falloff - more dramatic crater shape
                    let falloff;
                    if (t < 0.4) {
                        // Flatter bottom in the center 40% of the crater
                        falloff = 1.0;
                    } else {
                        // Steeper edges in the outer 60% of the crater
                        falloff = Math.pow(1 - ((t - 0.4) / 0.6), 2.5);
                    }
                    
                    const depth = maxDepth * falloff;
                    
                    // Lower the vertex to create the crater
                    position.setY(i, yPos - depth);
                    
                    // For the rim, slightly raise vertices near the edge
                    if (t > 0.8 && t <= 1.0) {
                        // Create a raised rim at the edge of the crater
                        const rimHeight = maxDepth * 0.3 * Math.pow((t - 0.8) / 0.2, 2);
                        position.setY(i, yPos - depth + rimHeight);
                    }
                }
            }
            
            // Update the geometry after all modifications
            position.needsUpdate = true;
            terrainGeometry.computeVertexNormals();
            
            // Check if any tank is near the impact and should be affected immediately
            // This makes tanks fall immediately if the ground beneath them is destroyed
            if (playerTank && computerTank) {
                const distanceToPlayer = Math.sqrt(Math.pow(playerTank.position.x - x, 2) + Math.pow(playerTank.position.z - z, 2));
                const distanceToComputer = Math.sqrt(Math.pow(computerTank.position.x - x, 2) + Math.pow(computerTank.position.z - z, 2));
                
                // If impact is close to a tank (within 2x the impact radius), set its position slightly above the terrain
                // to trigger gravity in the next frame
                if (distanceToPlayer < impactRadius * 2) {
                    // Get the new terrain height and add a small lift to trigger falling
                    const newTerrainHeight = getTerrainHeightAt(playerTank.position.x, playerTank.position.z);
                    const currentTankHeight = playerTank.position.y - 0.5; // Subtract the usual offset
                    
                    // If the tank is now significantly above the terrain due to the crater, start its fall
                    if (currentTankHeight > newTerrainHeight + 0.1) {
                        // Initialize falling velocity if the tank should start falling
                        playerTank.userData.velocity = 0.1; // Small initial velocity
                    }
                }
                
                if (distanceToComputer < impactRadius * 2) {
                    const newTerrainHeight = getTerrainHeightAt(computerTank.position.x, computerTank.position.z);
                    const currentTankHeight = computerTank.position.y - 0.5; // Subtract the usual offset
                    
                    if (currentTankHeight > newTerrainHeight + 0.1) {
                        computerTank.userData.velocity = 0.1; // Small initial velocity
                    }
                }
            }
        }
        
        function checkTankCollision() {
            if (!cannonball) return;
            
            // Check distance to player tank
            const distanceToPlayer = cannonball.position.distanceTo(playerTank.position);
            if (distanceToPlayer < 1 && !playerTurn) {
                handleTankHit(playerTank);
                return;
            }
            
            // Check distance to computer tank
            const distanceToComputer = cannonball.position.distanceTo(computerTank.position);
            if (distanceToComputer < 1 && playerTurn) {
                handleTankHit(computerTank);
                return;
            }
        }
        
        function handleTankHit(tank) {
            // Create more dramatic explosion effect
            createExplosion(cannonball.position.clone());
            
            // Add multiple smaller explosions
            for (let i = 0; i < 5; i++) { // Increased from 3 to 5 explosions
                setTimeout(() => {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 1.5, // Slightly wider spread
                        Math.random() * 0.7,         // Higher vertical spread
                        (Math.random() - 0.5) * 1.5  // Slightly wider spread
                    );
                    createExplosion(tank.position.clone().add(offset));
                }, i * 120); // Slightly faster sequence
            }
            
            // Add immediate dense smoke effect at hit location
            createDenseSmoke(tank.position.clone(), 30, 0x222222, 5);
            
            // More dramatic camera shake
            cameraShake(1.0, 1200, false); // Keep camera controls enabled during tank hits
            
            // If we're in a triple shot sequence, end it since we hit the target
            if (waitingForTripleShot) {
                const shotsFired = currentShot;
                const shotsRemaining = totalTripleShotBalls - currentShot;
                
                // Display message about the hit during triple shot
                document.getElementById('result-message').textContent = 
                    `Triple Shot: Direct hit on shot ${shotsFired} of ${totalTripleShotBalls}! ${shotsRemaining > 0 ? `${shotsRemaining} more shot${shotsRemaining > 1 ? 's' : ''} coming!` : 'That was the final shot!'}`;
                document.getElementById('result-message').style.color = '#00ffff';
                
                // Only end the sequence if this was the last shot
                if (shotsRemaining <= 0) {
                    waitingForTripleShot = false;
                    playerHasTripleShot = false;
                    tripleShotUsed = false;
                    currentShot = 0;
                    updatePowerupsDisplay();
                }
            }
            
            // Check if tank has shield (only player can have shield for now)
            if (tank === playerTank && playerHasShield) {
                // Shield absorbs the hit
                playerHasShield = false;
                
                // Remove shield visual effect
                const shield = tank.getObjectByName("shield");
                if (shield) tank.remove(shield);
                
                // Show shield protection message considering triple shot sequence
                if (waitingForTripleShot) {
                    const shotsFired = currentShot;
                    const shotsRemaining = totalTripleShotBalls - currentShot;
                    document.getElementById('result-message').textContent = 
                        `Your shield absorbed the hit! ${shotsRemaining > 0 ? `Triple shot continues, ${shotsRemaining} more shot${shotsRemaining > 1 ? 's' : ''} coming!` : ''}`;
                } else {
                    document.getElementById('result-message').textContent = "Your shield absorbed the hit!";
                }
                document.getElementById('result-message').style.color = '#00ffff';
                
                // Update powerups display
                updatePowerupsDisplay();
                
                // Reset cannonball
                resetCannonball();
                
                // Switch turns
                switchTurn();
                return;
            }
            
            // Calculate damage (reduced to take ~10 hits to destroy)
            const baseDamage = 10; // Changed from 20 to 10 to require ~10 hits
            const damageVariation = Math.random() * 2; // Reduced from 5 to 2 for more consistent damage
            const damage = Math.floor(baseDamage + damageVariation);
            
            // Apply damage to tank's health
            tank.userData.health = Math.max(0, tank.userData.health - damage);
            
            // Update health bar
            updateHealthBar(tank);
            
            // Update UI health bars
            updateUIHealthBars();
            
            // Update message with damage info
            if (tank === playerTank) {
                let message = `Computer hit you for ${damage} damage!`;
                if (waitingForTripleShot) {
                    const shotsRemaining = totalTripleShotBalls - currentShot;
                    if (shotsRemaining > 0) {
                        message += ` (Triple shot: ${shotsRemaining} more shot${shotsRemaining > 1 ? 's' : ''} coming)`;
                    }
                }
                document.getElementById('result-message').textContent = message;
                document.getElementById('result-message').style.color = '#ff5555';
            } else {
                let message = `You hit enemy for ${damage} damage!`;
                if (waitingForTripleShot) {
                    const shotsRemaining = totalTripleShotBalls - currentShot;
                    if (shotsRemaining > 0) {
                        message += ` (Triple shot: ${shotsRemaining} more shot${shotsRemaining > 1 ? 's' : ''} coming)`;
                    }
                }
                document.getElementById('result-message').textContent = message;
                document.getElementById('result-message').style.color = '#55ff55';
            }
            
            // Reset cannonball
            resetCannonball();
            
            // Check if tank is destroyed
            if (tank.userData.health <= 0) {
                // Tank destroyed
                if (tank === playerTank) {
                    document.getElementById('result-message').textContent = 'Your tank was destroyed!';
                    
                    // End triple shot sequence if active
                    waitingForTripleShot = false;
                    currentShot = 0;
                    
                    endGame(false); // Player lost
                } else {
                    // Enemy tank destroyed
                    document.getElementById('result-message').textContent = 'You destroyed the enemy tank!';
                    
                    // If in triple shot, we need to properly end the sequence and the game
                    if (waitingForTripleShot) {
                        document.getElementById('result-message').textContent = 
                            `You destroyed the enemy tank with shot ${currentShot} of ${totalTripleShotBalls}!`;
                        document.getElementById('result-message').style.color = '#55ff55';
                        
                        // Immediately end triple shot sequence since the target is destroyed
                        waitingForTripleShot = false;
                        playerHasTripleShot = false;
                        tripleShotUsed = false;
                        currentShot = 0;
                        
                        // End the game with player victory
                        setTimeout(() => {
                            endGame(true); // Player won
                        }, 1000); // Small delay to show the victory message
                        return;
                    }
                    
                    endGame(true); // Player won
                }
            } else {
                // Switch turns if game continues
                switchTurn();
            }
        }
        
        // New helper function to create dense smoke
        function createDenseSmoke(position, particleCount = 20, color = 0x444444, duration = 3) {
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const smokeGeometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.3, 8, 8);
                    const smokeMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8 + Math.random() * 0.2
                    });
                    
                    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                    
                    // Position around the hit area with broader spread
                    smoke.position.set(
                        position.x + (Math.random() - 0.5) * 1.2,
                        position.y + 0.5 + Math.random() * 1.0,
                        position.z + (Math.random() - 0.5) * 1.2
                    );
                    
                    // Set properties for more dramatic smoke
                    smoke.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.3,  // More horizontal drift
                            Math.random() * 0.7 + 0.5,    // More upward motion
                            (Math.random() - 0.5) * 0.3   // More z-axis drift
                        ),
                        rotationSpeed: (Math.random() - 0.5) * 0.02,
                        lifespan: duration + Math.random() * 3, // Longer lifespan
                        creationTime: Date.now(),
                        fadeDelay: 2.0 // Delay fading for 2 seconds
                    };
                    
                    scene.add(smoke);
                    smokeParticles.push(smoke);
                }, i * 30); // Stagger the creation for a more dynamic effect
            }
        }

        // New function to create a smoke ring effect from the cannon
        function createSmokeRing(position, direction, radius = 0.3, particleCount = 15, color = 0x888888) {
            // Create a ring of smoke particles perpendicular to the firing direction
            const ringGroup = new THREE.Group();
            ringGroup.position.copy(position);
            
            // Create a quaternion to rotate the ring to face the direction of firing
            const rotationQuat = new THREE.Quaternion();
            rotationQuat.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
            ringGroup.quaternion.copy(rotationQuat);
            
            // Create particles arranged in a circle
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                
                // Calculate position on the ring
                const x = Math.cos(angle) * radius;
                const y = 0; // Ring is flat (perpendicular to direction)
                const z = Math.sin(angle) * radius;
                
                // Create smoke particle
                const size = 0.08 + Math.random() * 0.08;
                const smokeGeometry = new THREE.SphereGeometry(size, 8, 8);
                const smokeMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7 + Math.random() * 0.3
                });
                
                const particle = new THREE.Mesh(smokeGeometry, smokeMaterial);
                particle.position.set(x, y, z);
                
                // Add particle to the ring group
                ringGroup.add(particle);
                
                // Use quaternion to transform from local to world space
                const worldPos = particle.getWorldPosition(new THREE.Vector3());
                
                // Remove from ring group and add directly to scene for independent movement
                ringGroup.remove(particle);
                particle.position.copy(worldPos);
                scene.add(particle);
                
                // Create outward velocity (radial expansion) plus forward movement
                const radialVelocity = new THREE.Vector3(x, y, z).normalize().multiplyScalar(0.8 + Math.random() * 0.5);
                
                // Add properties for animation
                particle.userData = {
                    velocity: new THREE.Vector3(
                        radialVelocity.x + direction.x * (0.2 + Math.random() * 0.3),
                        radialVelocity.y + direction.y * (0.2 + Math.random() * 0.3),
                        radialVelocity.z + direction.z * (0.2 + Math.random() * 0.3)
                    ),
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    lifespan: 1.0 + Math.random() * 0.5,
                    creationTime: Date.now(),
                    type: 'ring' // Used to identify ring particles for special animation
                };
                
                smokeParticles.push(particle);
            }
            
            // No need to keep the empty group
            scene.remove(ringGroup);
        }

        function resetCannonball() {
            if (cannonball) {
                scene.remove(cannonball);
                cannonball = null;
                cannonballVelocity = { x: 0, y: 0, z: 0 };
            }
        }
        
        function switchTurn() {
            // If game is no longer active, don't switch turns or continue triple shot
            if (!gameActive) {
                // Clear any remaining triple shot
                waitingForTripleShot = false;
                currentShot = 0;
                return;
            }

            // If we're in the middle of a triple shot sequence, continue with the next shot
            // instead of switching turns
            if (waitingForTripleShot && currentShot < totalTripleShotBalls) {
                // Fire the next shot in the triple shot sequence
                setTimeout(() => {
                    // Make sure game is still active before continuing triple shot
                    if (!gameActive) {
                        waitingForTripleShot = false;
                        currentShot = 0;
                        return;
                    }
                    
                    // Show message indicating which shot we're firing
                    document.getElementById('result-message').textContent = 
                        `Triple Shot: Firing shot ${currentShot + 1} of ${totalTripleShotBalls}`;
                    document.getElementById('result-message').style.color = '#00ffff';
                    
                    // Fire the next cannonball with angle offset
                    fireCannon(tripleShotAngles[currentShot]);
                    currentShot++;
                }, 1000);  // Wait a second between shots
                return;
            }
            
            // If we just finished the last shot of a triple shot, reset the flags
            if (waitingForTripleShot && currentShot >= totalTripleShotBalls) {
                waitingForTripleShot = false;
                playerHasTripleShot = false;
                tripleShotUsed = false;
                currentShot = 0;
                updatePowerupsDisplay();
                
                document.getElementById('result-message').textContent = 'Triple Shot sequence completed!';
                document.getElementById('result-message').style.color = '#00ffff';
            }
            
            // Normal turn switching
            playerTurn = !playerTurn;
            
            // Check if shield should expire - only when switching back to player's turn
            // This ensures shield stays active during the computer's turn
            if (playerTurn && playerHasShield) {
                // Remove shield from player tank (after computer has had chance to shoot)
                playerHasShield = false;
                const shield = playerTank.getObjectByName("shield");
                if (shield) playerTank.remove(shield);
                
                // Show message about shield expiration
                document.getElementById('result-message').textContent = "Your shield has expired!";
                document.getElementById('result-message').style.color = '#00ffff';
                
                // Update powerups display
                updatePowerupsDisplay();
            }
            
            // Re-enable controls
            document.getElementById('fire-button').disabled = false;
            
            // Set message
            if (playerTurn) {
                document.getElementById('result-message').textContent = 'Your turn!';
            } else {
                document.getElementById('result-message').textContent = 'Computer\'s turn...';
                // Computer takes its turn after a delay
                setTimeout(computerTurn, 2000);
            }
        }
        
        function computerTurn() {
            if (gameActive && !playerTurn) {
                // AI behavior - adjust angle based on player position
                const angleToPlayer = calculateAngleToTarget(computerTank, playerTank.position);
                
                // For computer tank facing left, adjust cannon angle
                computerTank.userData.cannon.rotation.z = Math.PI + angleToPlayer; // Start from PI (left) and add angle
                
                // Calculate power based on distance to player
                const distance = computerTank.position.distanceTo(playerTank.position);
                const power = Math.min(80, Math.max(30, distance * 3)); // Reduced factor from 5 to 3 to avoid overpowering computer shots
                
                // Fire with some random variation
                const randomAngle = angleToPlayer + (Math.random() - 0.5) * 0.2;
                const randomPower = power * (0.8 + Math.random() * 0.4) / 5; // Scale down less (changed from /10 to /5 to match player power)
                
                // Set velocity for computer's shot
                cannonballVelocity = {
                    x: -randomPower * Math.cos(randomAngle), // Negative X for shooting left
                    y: randomPower * Math.sin(randomAngle),
                    z: 0
                };
                
                // Create cannonball
                const cannonballGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const cannonballMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                cannonball = new THREE.Mesh(cannonballGeometry, cannonballMaterial);
                cannonball.castShadow = true;
                
                // Position at the computer tank's cannon
                const cannonWorldPos = new THREE.Vector3();
                computerTank.userData.cannon.getWorldPosition(cannonWorldPos);
                
                // Create direction vector pointing toward player (left/-X)
                const direction = new THREE.Vector3(
                    -Math.cos(randomAngle),
                    Math.sin(randomAngle),
                    0
                );
                
                // Position cannonball at end of barrel
                const cannonDirection = direction.clone().normalize();
                const cannonLength = 0.6;
                cannonWorldPos.add(cannonDirection.multiplyScalar(cannonLength));
                cannonball.position.copy(cannonWorldPos);
                
                scene.add(cannonball);
                
                // Create muzzle flash and smoke effects for computer's cannon too
                // Muzzle flash
                const muzzleFlashGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const muzzleFlashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 1
                });
                const muzzleFlash = new THREE.Mesh(muzzleFlashGeometry, muzzleFlashMaterial);
                muzzleFlash.position.copy(cannonWorldPos);
                scene.add(muzzleFlash);
                
                // Add a point light for the muzzle flash
                const flashLight = new THREE.PointLight(0xffff00, 2, 3);
                flashLight.position.copy(cannonWorldPos);
                scene.add(flashLight);
                
                // Fade out muzzle flash
                setTimeout(() => {
                    scene.remove(muzzleFlash);
                    scene.remove(flashLight);
                }, 100);
                
                // Create smoke ring for computer's cannon
                createSmokeRing(cannonWorldPos, direction);
                
                // Create regular smoke particles
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const smokeGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 8, 8);
                        const smokeMaterial = new THREE.MeshBasicMaterial({
                            color: 0x888888,
                            transparent: true,
                            opacity: 0.7
                        });
                        
                        const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                        smoke.position.copy(cannonWorldPos);
                        smoke.position.x += (Math.random() - 0.5) * 0.2;
                        smoke.position.y += (Math.random() - 0.5) * 0.2;
                        smoke.position.z += (Math.random() - 0.5) * 0.2;
                        
                        smoke.userData = {
                            velocity: new THREE.Vector3(
                                direction.x * (Math.random() * 0.5 + 0.5),
                                direction.y * (Math.random() * 0.5 + 0.5) + Math.random() * 0.5,
                                direction.z * (Math.random() * 0.5 + 0.5)
                            ),
                            rotationSpeed: (Math.random() - 0.5) * 0.01,
                            lifespan: 1 + Math.random(),
                            creationTime: Date.now()
                        };
                        
                        scene.add(smoke);
                        smokeParticles.push(smoke);
                    }, i * 20);
                }
                
                // Shake camera - REMOVED to keep shake only on collisions
                // cameraShake(0.2, 300);
                
                // Disable fire button during computer's turn
                document.getElementById('fire-button').disabled = true;
            }
        }
        
        function calculateAngleToTarget(tank, targetPosition) {
            // Calculate the angle to hit the target
            const distance = Math.sqrt(
                Math.pow(targetPosition.x - tank.position.x, 2) +
                Math.pow(targetPosition.z - tank.position.z, 2)
            );
            
            // Calculate height difference
            const heightDiff = targetPosition.y - tank.position.y;
            
            // Simple ballistic calculation - improved to account for distance and height
            // Returns an angle in radians
            const baseAngle = Math.atan2(distance, heightDiff) / 2;
            
            // Add some randomness for the computer (between 0.2 and 0.4 radians)
            return Math.min(Math.PI/3, Math.max(0.1, baseAngle));
        }
        
        function cameraShake(intensity, duration, disableControls = false) {
            // Store original camera position and target
            const originalPosition = camera.position.clone();
            
            // Temporarily disable controls to avoid conflicts, only if disableControls is true
            const controlsEnabled = controls.enabled;
            if (disableControls) {
                controls.enabled = false;
            }
            
            let elapsed = 0;
            let lastTime = performance.now();
            let shakeActive = true;
            
            function shakeStep() {
                if (!shakeActive) return;
                
                const now = performance.now();
                const delta = (now - lastTime) / 1000; // Convert to seconds
                lastTime = now;
                
                elapsed += delta;
                
                if (elapsed < duration / 1000) {
                    // Apply random offset with decreasing intensity over time
                    const remaining = 1 - (elapsed / (duration / 1000));
                    camera.position.set(
                        originalPosition.x + (Math.random() - 0.5) * intensity * remaining,
                        originalPosition.y + (Math.random() - 0.5) * intensity * remaining,
                        originalPosition.z + (Math.random() - 0.5) * intensity * remaining
                    );
                    
                    // Force camera update in the render loop
                    camera.updateProjectionMatrix();
                    
                    // Continue shake on next frame
                    requestAnimationFrame(shakeStep);
                } else {
                    // Reset to original position
                    camera.position.copy(originalPosition);
                    camera.updateProjectionMatrix();
                    
                    // Re-enable controls only if we disabled them
                    if (disableControls) {
                        controls.enabled = controlsEnabled;
                    }
                    
                    // Mark shake as complete
                    shakeActive = false;
                }
            }
            
            // Start shake animation
            requestAnimationFrame(shakeStep);
            
            // Safety timeout to ensure controls are re-enabled
            setTimeout(() => {
                if (shakeActive) {
                    shakeActive = false;
                    camera.position.copy(originalPosition);
                    camera.updateProjectionMatrix();
                    
                    // Only re-enable if we disabled them
                    if (disableControls) {
                        controls.enabled = controlsEnabled;
                    }
                }
            }, duration + 100);
        }
        
        function endGame(playerWon) {
            gameActive = false;
            
            // Clear any active triple shot sequence
            waitingForTripleShot = false;
            currentShot = 0;
            
            // Display end game message with more dramatic effect
            const message = playerWon 
                ? 'You win! Great job with your math skills!'
                : 'Computer wins! Keep practicing your math!';
                
            document.getElementById('result-message').textContent = message;
            document.getElementById('result-message').style.fontSize = '18px';
            
            // Disable fire button
            document.getElementById('fire-button').disabled = true;
            
            // Add option to restart
            const restart = document.createElement('button');
            restart.textContent = 'Play Again';
            restart.style.marginTop = '10px';
            restart.style.padding = '10px 20px';
            restart.style.fontSize = '16px';
            restart.addEventListener('click', () => {
                location.reload();
            });
            
            document.getElementById('game-ui').appendChild(restart);
            
            // Add visual celebration effects for winner
            if (playerWon) {
                createVictoryEffects(playerTank.position);
                // Add smoke to losing computer tank's cannon
                createLosingTankSmoke(computerTank);
            } else {
                createVictoryEffects(computerTank.position);
                // Add smoke to losing player tank's cannon
                createLosingTankSmoke(playerTank);
            }
        }
        
        // Function to create continuous smoke from the losing tank's cannon
        function createLosingTankSmoke(tank) {
            // Get cannon world position
            const cannonWorldPos = new THREE.Vector3();
            tank.userData.cannon.getWorldPosition(cannonWorldPos);
            
            // Create initial burst of dense smoke and sparks
            createInitialExplosion(cannonWorldPos.clone());
            
            // Store reference to the interval so we can clear it if needed
            const smokeInterval = setInterval(() => {
                // Create dense, black smoke with varied sizes
                const particleSize = 0.15 + Math.random() * 0.25; // Larger particles (was 0.1 + random * 0.15)
                const smokeGeometry = new THREE.SphereGeometry(particleSize, 8, 8);
                
                // Mix of dark smoke (black, dark gray) and some fire particles (orange/red)
                let smokeMaterial;
                if (Math.random() < 0.15) { // 15% chance of fire particles
                    // Create glowing ember/fire particle
                    smokeMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(
                            0.8 + Math.random() * 0.2, // Red
                            0.2 + Math.random() * 0.3, // Green
                            0.0                        // Blue
                        ),
                        transparent: true,
                        opacity: 0.9
                    });
                } else {
                    // Dark smoke with color variation
                    const darkness = Math.random() * 0.2; // 0-0.2 (darker)
                    smokeMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(darkness, darkness, darkness), // Very dark smoke
                        transparent: true,
                        opacity: 0.9
                    });
                }
                
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                
                // Position smoke at the end of the cannon with more variation
                smoke.position.copy(cannonWorldPos);
                
                // Add some random variation to the position - wider spread
                smoke.position.x += (Math.random() - 0.5) * 0.2;
                smoke.position.y += (Math.random() - 0.5) * 0.2;
                smoke.position.z += (Math.random() - 0.5) * 0.2;
                
                // Set longer lifespan for the smoke and more dramatic movement
                smoke.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,  // More horizontal drift
                        Math.random() * 0.7 + 0.5,    // Faster rise upward
                        (Math.random() - 0.5) * 0.2   // More depth drift
                    ),
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    lifespan: 5 + Math.random() * 3, // Longer lifespan (was 4 + random * 2)
                    creationTime: Date.now(),
                    fadeDelay: 1.5 // Wait longer before fading
                };
                
                scene.add(smoke);
                smokeParticles.push(smoke);
                
                // Limit the number of smoke particles to prevent performance issues
                if (smokeParticles.length > 300) { // Increased from 200 to 300
                    clearInterval(smokeInterval);
                }
            }, 70); // Increased frequency (was 100ms)
            
            // Create occasional small secondary explosions for dramatic effect
            const explosionInterval = setInterval(() => {
                if (Math.random() < 0.3) { // 30% chance each interval
                    // Position with slight offset from cannon
                    const explosionPos = cannonWorldPos.clone();
                    explosionPos.x += (Math.random() - 0.5) * 0.3;
                    explosionPos.y += (Math.random() - 0.5) * 0.3;
                    explosionPos.z += (Math.random() - 0.5) * 0.3;
                    
                    // Create small explosion effect
                    const smallExplosion = new THREE.PointLight(0xff5500, 3, 2);
                    smallExplosion.position.copy(explosionPos);
                    scene.add(smallExplosion);
                    
                    // Remove after short duration
                    setTimeout(() => {
                        scene.remove(smallExplosion);
                    }, 150);
                    
                    // Add some sparks
                    for (let i = 0; i < 5; i++) {
                        const sparkGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                        const sparkMaterial = new THREE.MeshBasicMaterial({
                            color: Math.random() < 0.5 ? 0xff7700 : 0xffaa00,
                            transparent: true,
                            opacity: 1
                        });
                        
                        const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                        spark.position.copy(explosionPos);
                        
                        // Random direction for sparks
                        const angle = Math.random() * Math.PI * 2;
                        const elevation = Math.random() * Math.PI;
                        const speed = Math.random() * 2 + 2;
                        
                        spark.userData = {
                            velocity: new THREE.Vector3(
                                Math.cos(angle) * Math.sin(elevation) * speed,
                                Math.cos(elevation) * speed,
                                Math.sin(angle) * Math.sin(elevation) * speed
                            ),
                            rotationSpeed: (Math.random() - 0.5) * 0.1,
                            lifespan: 0.5 + Math.random() * 0.5,
                            creationTime: Date.now()
                        };
                        
                        scene.add(spark);
                        smokeParticles.push(spark);
                    }
                }
            }, 800); // Check for secondary explosions every 800ms
            
            // Clear explosion interval after 10 seconds
            setTimeout(() => {
                clearInterval(explosionInterval);
            }, 10000);
        }

        // New function for initial large explosion when tank loses
        function createInitialExplosion(position) {
            // Create a bright flash of light
            const flash = new THREE.PointLight(0xffff00, 8, 5);
            flash.position.copy(position);
            scene.add(flash);
            
            // Create initial explosion mesh
            const explosionGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(position);
            scene.add(explosion);
            
            // Create lots of initial sparks and debris
            for (let i = 0; i < 30; i++) {
                const sparkGeometry = new THREE.SphereGeometry(0.07 + Math.random() * 0.05, 8, 8);
                
                // Mix of colors for more dramatic effect
                const colorChoice = Math.random();
                let sparkColor;
                
                if (colorChoice < 0.6) {
                    // Orange/yellow spark
                    sparkColor = new THREE.Color(
                        0.9 + Math.random() * 0.1,  // Red
                        0.5 + Math.random() * 0.3,  // Green
                        0                           // Blue
                    );
                } else if (colorChoice < 0.9) {
                    // White/yellow spark
                    sparkColor = new THREE.Color(
                        0.9 + Math.random() * 0.1,  // Red
                        0.9 + Math.random() * 0.1,  // Green
                        0.5 + Math.random() * 0.3   // Blue
                    );
                } else {
                    // Occasional red spark
                    sparkColor = new THREE.Color(
                        0.9 + Math.random() * 0.1,  // Red
                        0.1 + Math.random() * 0.1,  // Green
                        0.1                         // Blue
                    );
                }
                
                const sparkMaterial = new THREE.MeshBasicMaterial({
                    color: sparkColor,
                    transparent: true,
                    opacity: 1
                });
                
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.copy(position);
                
                // Random direction with higher velocity
                const angle = Math.random() * Math.PI * 2;
                const elevation = Math.random() * Math.PI;
                const speed = Math.random() * 4 + 3;
                
                spark.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * Math.sin(elevation) * speed,
                        Math.cos(elevation) * speed,
                        Math.sin(angle) * Math.sin(elevation) * speed
                    ),
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    lifespan: 0.7 + Math.random() * 0.8,
                    creationTime: Date.now()
                };
                
                scene.add(spark);
                smokeParticles.push(spark);
            }
            
            // Create initial dark smoke burst
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const smokeSize = 0.2 + Math.random() * 0.3;
                    const smokeGeometry = new THREE.SphereGeometry(smokeSize, 8, 8);
                    const smokeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x222222,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                    smoke.position.copy(position);
                    smoke.position.x += (Math.random() - 0.5) * 0.5;
                    smoke.position.y += (Math.random() - 0.5) * 0.5;
                    smoke.position.z += (Math.random() - 0.5) * 0.5;
                    
                    smoke.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 1.0,
                            Math.random() * 1.5 + 1.0,
                            (Math.random() - 0.5) * 1.0
                        ),
                        rotationSpeed: (Math.random() - 0.5) * 0.03,
                        lifespan: 3 + Math.random() * 2,
                        creationTime: Date.now()
                    };
                    
                    scene.add(smoke);
                    smokeParticles.push(smoke);
                }, i * 50);
            }
            
            // Remove the flash and explosion after a short time
            setTimeout(() => {
                scene.remove(flash);
                scene.remove(explosion);
            }, 300);
        }
        
        function createVictoryEffects(position) {
            // Create victory fireworks effect - more spectacular
            for (let i = 0; i < 25; i++) { // Increased from 20 to 25 fireworks
                setTimeout(() => {
                    // Randomize the firework type
                    const fireworkType = Math.floor(Math.random() * 4); // 0-3 different types
                    
                    // Varied position offsets for more interesting distribution
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 15,  // Wider spread
                        5 + Math.random() * 8,       // Higher altitude
                        (Math.random() - 0.5) * 8    // Deeper spread
                    );
                    const fireworkPosition = position.clone().add(offset);
                    
                    // Create colorful explosion
                    const fireworkGroup = new THREE.Group();
                    fireworkGroup.position.copy(fireworkPosition);
                    fireworkGroup.userData.creationTime = Date.now();
                    fireworkGroup.userData.duration = 2.0; // Longer duration
                    fireworkGroup.userData.type = fireworkType; // Store type for animation
                    
                    // Generate a vibrant color - avoid dull colors
                    let hue = Math.random();
                    let saturation = 0.8 + Math.random() * 0.2; // High saturation
                    let lightness = 0.5 + Math.random() * 0.3;  // Brighter
                    const color = new THREE.Color().setHSL(hue, saturation, lightness);
                    
                    // Add brighter light with longer range
                    const fireworkLight = new THREE.PointLight(color, 4, 8);
                    fireworkLight.position.set(0, 0, 0);
                    fireworkGroup.add(fireworkLight);
                    
                    // Create particles based on firework type
                    const particleCount = fireworkType === 3 ? 50 : 30; // Special type has more particles
                    
                    for (let j = 0; j < particleCount; j++) {
                        // Varied particle sizes
                        const particleSize = (fireworkType === 2) 
                            ? 0.08 + Math.random() * 0.12 // Varied sizes for type 2
                            : 0.1;
                        
                        const particleGeometry = new THREE.SphereGeometry(particleSize, 8, 8);
                        
                        // For type 1, use complementary colors
                        let particleColor;
                        if (fireworkType === 1 && j % 3 === 0) {
                            // Add some particles with complementary color
                            particleColor = new THREE.Color().setHSL((hue + 0.5) % 1, saturation, lightness);
                        } else {
                            particleColor = color.clone();
                        }
                        
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: particleColor,
                            transparent: true,
                            opacity: 1
                        });
                        
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Different particle distribution based on type
                        let direction;
                        
                        if (fireworkType === 0) {
                            // Spherical distribution (classic firework)
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.random() * Math.PI * 2;
                            
                            direction = new THREE.Vector3(
                                Math.sin(phi) * Math.cos(theta),
                                Math.sin(phi) * Math.sin(theta),
                                Math.cos(phi)
                            );
                        } 
                        else if (fireworkType === 1) {
                            // Ring distribution (flat circular)
                            const angle = (j / particleCount) * Math.PI * 2;
                            const variance = (Math.random() - 0.5) * 0.2;
                            
                            direction = new THREE.Vector3(
                                Math.cos(angle) + variance,
                                (Math.random() - 0.5) * 0.3, // slight vertical variance
                                Math.sin(angle) + variance
                            );
                        }
                        else if (fireworkType === 2) {
                            // Double sphere (two layers)
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.random() * Math.PI * 2;
                            const radius = (j % 2 === 0) ? 1 : 0.6;
                            
                            direction = new THREE.Vector3(
                                radius * Math.sin(phi) * Math.cos(theta),
                                radius * Math.sin(phi) * Math.sin(theta),
                                radius * Math.cos(phi)
                            );
                        }
                        else if (fireworkType === 3) {
                            // Spiral pattern
                            const angle = (j / particleCount) * Math.PI * 10; // Multiple rotations
                            const height = ((j / particleCount) * 2) - 1; // -1 to 1
                            const radius = 1 - Math.abs(height) * 0.5; // Thinner at edges
                            
                            direction = new THREE.Vector3(
                                radius * Math.cos(angle),
                                height,
                                radius * Math.sin(angle)
                            );
                        }
                        
                        // Normalize and add some randomness
                        direction.normalize().multiplyScalar(Math.random() * 0.5 + 1.5);
                        
                        // Store velocity for animation
                        particle.userData.velocity = direction;
                        particle.userData.rotationSpeed = Math.random() * 0.2;
                        particle.userData.type = fireworkType;
                        
                        fireworkGroup.add(particle);
                    }
                    
                    // Add trail particles that rise up before explosion
                    if (i % 3 === 0) { // Only for some fireworks
                        createFireworkTrail(position.clone(), fireworkPosition.clone(), color);
                    }
                    
                    scene.add(fireworkGroup);
                    explosionGroups.push(fireworkGroup);
                    
                }, i * 200 + Math.random() * 300); // Variable timing
            }
        }

        // New function to create a trail for a rising firework
        function createFireworkTrail(startPosition, endPosition, color) {
            const trailDuration = 1.0; // 1 second to rise
            const startTime = Date.now();
            
            // Create the rising firework
            const rocketGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const rocketMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1
            });
            
            const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
            rocket.position.copy(startPosition);
            
            // Add a small light
            const rocketLight = new THREE.PointLight(color, 2, 3);
            rocketLight.position.copy(startPosition);
            
            scene.add(rocket);
            scene.add(rocketLight);
            
            // Calculate velocity vector
            const velocity = new THREE.Vector3()
                .subVectors(endPosition, startPosition)
                .divideScalar(trailDuration); // Units per second
            
            // Start animation sequence
            const trailInterval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                
                if (elapsed < trailDuration) {
                    // Update position
                    const newPos = new THREE.Vector3()
                        .copy(startPosition)
                        .add(velocity.clone().multiplyScalar(elapsed));
                    
                    rocket.position.copy(newPos);
                    rocketLight.position.copy(newPos);
                    
                    // Create trail particles
                    if (Math.random() > 0.5) {
                        const trailGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                        const trailMaterial = new THREE.MeshBasicMaterial({
                            color: color,
                            transparent: true,
                            opacity: 0.7
                        });
                        
                        const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                        trail.position.copy(newPos);
                        trail.position.x += (Math.random() - 0.5) * 0.1;
                        trail.position.y += (Math.random() - 0.5) * 0.1;
                        trail.position.z += (Math.random() - 0.5) * 0.1;
                        
                        trail.userData = {
                            velocity: new THREE.Vector3(0, 0, 0),
                            lifespan: 0.5,
                            creationTime: Date.now(),
                            fadeSpeed: 0.05
                        };
                        
                        scene.add(trail);
                        smokeParticles.push(trail);
                    }
                } else {
                    // Animation complete, clean up
                    clearInterval(trailInterval);
                    scene.remove(rocket);
                    scene.remove(rocketLight);
                }
            }, 16); // Approximately 60 FPS
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            try {
                const deltaTime = 1/60; // Fixed time step
                const currentTime = Date.now();
                
                // Update the tank's position and orientation based on terrain - with safety checks
                try {
                    if (playerTank && computerTank && terrain) {
                        updateTankPositions();
                    }
                } catch (posError) {
                    console.error("Error in updateTankPositions:", posError);
                }
                
                // Update cannon positions and orientations - with safety checks
                try {
                    if (playerTank && playerTank.userData && playerTank.userData.cannon &&
                        computerTank && computerTank.userData && computerTank.userData.cannon) {
                        updateCannons();
                    }
                } catch (cannonError) {
                    console.error("Error in updateCannons:", cannonError);
                }
                
                // Update cannonball physics - additional safety check
                if (cannonball && cannonball.position) {
                    try {
                        updateCannonball(deltaTime);
                        
                        // Add cannonball trail effect in its own try-catch
                        try {
                            if (Math.random() > 0.6 && cannonball && cannonball.position) {
                                createCannonballTrail(cannonball.position.clone());
                            }
                        } catch (trailError) {
                            console.error("Error creating cannonball trail:", trailError);
                            // Continue without trail if there's an error
                        }
                    } catch (ballError) {
                        console.error("Error updating cannonball:", ballError);
                        resetCannonball();
                    }
                } else if (cannonball && !cannonball.position) {
                    // If cannonball exists but has no position, reset it
                    console.warn("Cannonball exists but has no position property");
                    resetCannonball();
                }
                
                // Update explosion animations
                updateExplosions(deltaTime, currentTime);
                
                // Update smoke and debris particles
                updateParticles(deltaTime, currentTime);
                
                // Update controls
                if (controls) {
                    controls.update();
                }
                
                // Periodically force shadow updates (every 30 frames or ~0.5 seconds)
                if (Math.random() < 0.03) { // ~3% chance per frame
                    updateShadows();
                }
                
                // Render scene
                if (scene && camera && renderer) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error("Error in animation loop:", error);
                // Don't stop the animation loop for recoverable errors
            }
        }

        // New function to apply gravity to tanks
        function applyTankGravity(tank, deltaTime) {
            if (!tank || !terrain) return;
            
            // Get current tank position
            const tankPosition = tank.position.clone();
            
            // Check terrain height at multiple points under the tank for better stability
            // Check at four corners and center of the tank's base
            const halfWidth = 0.6;  // Half the tank width
            const halfLength = 0.6; // Half the tank length
            
            // Get heights at multiple sampling points
            const heightFrontLeft = getTerrainHeightAt(tankPosition.x - halfWidth, tankPosition.z - halfLength);
            const heightFrontRight = getTerrainHeightAt(tankPosition.x + halfWidth, tankPosition.z - halfLength);
            const heightBackLeft = getTerrainHeightAt(tankPosition.x - halfWidth, tankPosition.z + halfLength);
            const heightBackRight = getTerrainHeightAt(tankPosition.x + halfWidth, tankPosition.z + halfLength);
            const heightCenter = getTerrainHeightAt(tankPosition.x, tankPosition.z);
            
            // Use a weighted combination of the average and the center point
            // This gives more weight to the center, ensuring better stability
            const weightedHeight = (heightCenter * 3 + heightFrontLeft + heightFrontRight + heightBackLeft + heightBackRight) / 7;
            
            // Also calculate the max height for better ground contact
            const maxHeight = Math.max(heightFrontLeft, heightFrontRight, heightBackLeft, heightBackRight, heightCenter);
            
            // Use a blend of weighted average and max height
            // This ensures we don't float too much but also don't tilt excessively
            const terrainHeight = weightedHeight * 0.7 + maxHeight * 0.3;
            
            // Calculate the target position with the tank's base at terrain height
            // Adding 0.5 as that appears to be the initial y-offset when creating the tanks
            const targetHeight = terrainHeight + 0.5;
            
            // Calculate tilt angles based on terrain differences
            // Calculate pitch (front-to-back tilt)
            let pitchAngle = Math.atan2(
                (heightBackLeft + heightBackRight) / 2 - (heightFrontLeft + heightFrontRight) / 2, 
                halfLength * 2
            );
            
            // Calculate roll (side-to-side tilt)
            let rollAngle = Math.atan2(
                (heightFrontRight + heightBackRight) / 2 - (heightFrontLeft + heightBackLeft) / 2,
                halfWidth * 2
            );
            
            // Apply limits to prevent excessive tilting
            // Max tilt of 15 degrees (in radians) in any direction
            const maxTiltAngle = THREE.MathUtils.degToRad(15);
            pitchAngle = THREE.MathUtils.clamp(pitchAngle, -maxTiltAngle, maxTiltAngle);
            rollAngle = THREE.MathUtils.clamp(rollAngle, -maxTiltAngle, maxTiltAngle);
            
            // Scale down the angles for more subtle tilting
            pitchAngle *= 0.4;
            rollAngle *= 0.4;
            
            // Apply rotation to match terrain slope (smoothly)
            const rotationSpeed = 3.0 * deltaTime; // Reduced for more gentle rotation
            
            // Smoothly adjust rotation to match terrain
            tank.rotation.z = THREE.MathUtils.lerp(tank.rotation.z, rollAngle, rotationSpeed);
            tank.rotation.x = THREE.MathUtils.lerp(tank.rotation.x, pitchAngle, rotationSpeed);
            
            // Check if tank is above the terrain
            if (Math.abs(tankPosition.y - targetHeight) > 0.01) {
                // Store current velocity in tank userData if it doesn't exist
                if (!tank.userData.velocity) {
                    tank.userData.velocity = 0;
                }
                
                // Apply gravity to velocity
                tank.userData.velocity += gravity * deltaTime * 0.6; // Moderate gravity
                
                // Apply velocity to position (falling)
                tank.position.y -= tank.userData.velocity * deltaTime;
                
                // Check if tank has reached or gone below target height
                if (tank.position.y <= targetHeight) {
                    // Stop at the ground
                    tank.position.y = targetHeight;
                    tank.userData.velocity = 0;
                    
                    // Add dust effect when tank lands from a significant height
                    if (tank.userData.velocity > 1.0) {
                        // Create dust cloud when tank lands
                        createDenseSmoke(
                            new THREE.Vector3(tankPosition.x, targetHeight, tankPosition.z), 
                            10, // Number of particles
                            0xAAAAAA, // Dust color
                            1.5  // Duration
                        );
                    }
                }
                
                // Update the cannon angle if this is the computer tank
                if (tank === computerTank && !playerTurn) {
                    // Recalculate angle to player since tank position has changed
                    const angleToPlayer = calculateAngleToTarget(computerTank, playerTank.position);
                    computerTank.userData.cannon.rotation.z = Math.PI + angleToPlayer;
                }
            } else {
                // Tank is on the ground, reset velocity and ensure it's at the exact height
                tank.position.y = targetHeight;
                tank.userData.velocity = 0;
            }
        }

        function createCannonballTrail(position) {
            if (!position) {
                console.warn("Attempted to create trail with null position");
                return;
            }
            
            try {
                // Create a small trail particle behind the cannonball
                const trailGeometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.05, 8, 8);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.7
                });
                
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(position);
                
                // Add some random variation to trail position
                trail.position.x += (Math.random() - 0.5) * 0.05;
                trail.position.y += (Math.random() - 0.5) * 0.05;
                trail.position.z += (Math.random() - 0.5) * 0.05;
                
                // Store trail properties
                trail.userData = {
                    scale: Math.random() * 0.5 + 0.5,
                    fadeSpeed: Math.random() * 0.03 + 0.02,
                    lifespan: 0.5,
                    creationTime: Date.now()
                };
                
                scene.add(trail);
                smokeParticles.push(trail);
            } catch (error) {
                console.error("Error in createCannonballTrail:", error);
                // Continue without creating the trail
            }
        }

        function updateExplosions(deltaTime, currentTime) {
            // Update explosion animations
            for (let i = explosionGroups.length - 1; i >= 0; i--) {
                const group = explosionGroups[i];
                
                // Safety check - skip groups that don't have necessary data
                if (!group || !group.userData || group.userData.creationTime === undefined) {
                    if (group) scene.remove(group);
                    explosionGroups.splice(i, 1);
                    continue;
                }
                
                const elapsed = (currentTime - group.userData.creationTime) / 1000;
                
                // Check if explosion is still active
                if (elapsed < group.userData.duration) {
                    // Find core mesh and light
                    const core = group.children.find(child => child.userData && child.userData.isCore);
                    const light = group.children.find(child => child instanceof THREE.PointLight);
                    
                    // Scale and fade explosion core if it exists
                    if (core && core.material) {
                        // If it's a firework, use special animation
                        if (group.userData.type !== undefined) {
                            // Scale core based on type
                            const progress = elapsed / group.userData.duration;
                            let scaleFactor;
                            
                            // Different expansion rates for different firework types
                            if (group.userData.type === 0) { // Classic firework
                                scaleFactor = 1 + progress * 2;
                            } else if (group.userData.type === 1) { // Ring
                                scaleFactor = 1 + progress * 3;
                            } else if (group.userData.type === 2) { // Double sphere
                                scaleFactor = 1 + progress * 2.5;
                            } else { // Spiral
                                scaleFactor = 1 + progress * 2;
                            }
                            
                            core.scale.set(scaleFactor, scaleFactor, scaleFactor);
                            
                            // Fade out core
                            core.material.opacity = Math.max(0, 1 - progress * 2);
                        } else {
                            // Regular explosion
                            const scale = 1 + elapsed * 4; // Expand over time
                            core.scale.set(scale, scale, scale);
                            
                            // Fade out
                            core.material.opacity = Math.max(0, 1 - (elapsed / group.userData.duration) * 2);
                        }
                    }
                    
                    // Adjust light intensity if it exists
                    if (light) {
                        // Special handling for fireworks
                        if (group.userData.type !== undefined) {
                            // Base reduction in intensity
                            light.intensity = 4 * (1 - elapsed / group.userData.duration);
                            
                            // Color changing effect for some firework types
                            if (group.userData.type === 1 || group.userData.type === 3) {
                                const hue = (elapsed * 0.5) % 1; // Cycle through colors
                                light.color.setHSL(hue, 0.8, 0.5);
                            }
                        } else {
                            // Normal explosion - regular fade
                            // Make sure the light fades completely to zero
                            light.intensity = 5 * Math.max(0, 1 - elapsed / group.userData.duration);
                        }
                    }
                    
                    // Update particles with special animations based on firework type
                    group.children.forEach(child => {
                        if (child instanceof THREE.Mesh && child !== core) {
                            if (child.userData && child.userData.velocity) {
                                // Get type (if it's a firework)
                                const particleType = child.userData.type !== undefined ? child.userData.type : -1;
                                
                                // Base movement for all particles
                                const baseVelocity = child.userData.velocity.clone().multiplyScalar(deltaTime);
                                
                                // Apply special movement based on type
                                if (particleType === 1) {
                                    // Ring type - add oscillation
                                    baseVelocity.y += Math.sin(elapsed * 10) * 0.02;
                                } 
                                else if (particleType === 2) {
                                    // Double sphere - add spiraling
                                    const rotSpeed = child.userData.rotationSpeed || 0.1;
                                    const rotAngle = elapsed * rotSpeed * 10;
                                    const radius = baseVelocity.length() * 0.1;
                                    
                                    baseVelocity.x += Math.cos(rotAngle) * radius;
                                    baseVelocity.z += Math.sin(rotAngle) * radius;
                                }
                                else if (particleType === 3) {
                                    // Spiral - add continuous rotation
                                    const angle = elapsed * 5;
                                    const originalLength = baseVelocity.length();
                                    
                                    // Rotate velocity vector around y-axis
                                    const newX = baseVelocity.x * Math.cos(angle) - baseVelocity.z * Math.sin(angle);
                                    const newZ = baseVelocity.x * Math.sin(angle) + baseVelocity.z * Math.cos(angle);
                                    
                                    baseVelocity.x = newX;
                                    baseVelocity.z = newZ;
                                }
                                
                                // Apply the calculated velocity
                                child.position.add(baseVelocity);
                                
                                // Apply gravity - stronger for regular explosions, lighter for fireworks
                                if (particleType >= 0) {
                                    // Firework - lighter gravity
                                    child.userData.velocity.y -= gravity * deltaTime * 0.1;
                                } else {
                                    // Regular explosion - normal gravity
                                    child.userData.velocity.y -= gravity * deltaTime * 0.3;
                                }
                                
                                // Apply rotation if specified
                                if (child.userData.rotationSpeed) {
                                    child.rotation.y += child.userData.rotationSpeed;
                                    child.rotation.x += child.userData.rotationSpeed * 0.5;
                                }
                                
                                // Fade out particles over time - with different patterns
                                if (child.material) {
                                    if (particleType >= 0) {
                                        // Firework particles - more varied fading
                                        const fadeStart = group.userData.duration * 0.2; // Start fading after 20% of duration
                                        
                                        if (elapsed > fadeStart) {
                                            const fadeProgress = (elapsed - fadeStart) / (group.userData.duration - fadeStart);
                                            child.material.opacity = Math.max(0, 1 - fadeProgress);
                                            
                                            // Particles fade out with twinkling effect
                                            if (particleType === 3 || particleType === 1) {
                                                child.material.opacity *= (0.7 + 0.3 * Math.sin(elapsed * 20 + child.position.x * 10));
                                            }
                                        }
                                    } else {
                                        // Regular explosion particles - normal fade
                                        child.material.opacity = Math.max(0, 1 - (elapsed / group.userData.duration));
                                    }
                                    
                                    // Scale particles differently based on type
                                    let scale;
                                    if (particleType === 0) {
                                        // Classic firework - shrink gradually
                                        scale = Math.max(0.1, 1 - (elapsed / group.userData.duration) * 0.7);
                                    } 
                                    else if (particleType === 1 || particleType === 3) {
                                        // Ring and spiral - maintain size longer then shrink rapidly
                                        scale = elapsed < (group.userData.duration * 0.7) ?
                                            1 : 1 - ((elapsed - group.userData.duration * 0.7) / (group.userData.duration * 0.3));
                                    }
                                    else if (particleType === 2) {
                                        // Double sphere - pulsate slightly
                                        scale = Math.max(0.1, 1 - (elapsed / group.userData.duration) * 0.5);
                                        scale *= (0.8 + 0.2 * Math.sin(elapsed * 15 + child.position.y * 5));
                                    }
                                    else {
                                        // Regular explosion particles
                                        scale = Math.max(0.1, 1 - (elapsed / group.userData.duration) * 0.5);
                                    }
                                    
                                    child.scale.set(scale, scale, scale);
                                }
                            }
                        }
                    });
                } else {
                    // Ensure the explosion light is fully faded out before removing
                    const light = group.children.find(child => child instanceof THREE.PointLight);
                    if (light) {
                        light.intensity = 0;
                    }
                    
                    // Remove expired explosion group and all its children
                    while (group.children.length > 0) {
                        const child = group.children[0];
                        group.remove(child);
                    }
                    scene.remove(group);
                    explosionGroups.splice(i, 1);
                }
            }
        }

        function updateParticles(deltaTime, currentTime) {
            // Update smoke and debris particles
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const particle = smokeParticles[i];
                
                // Safety check - skip particles that don't have necessary data
                if (!particle || !particle.userData || !particle.position) {
                    // Remove invalid particle
                    if (particle) scene.remove(particle);
                    smokeParticles.splice(i, 1);
                    continue;
                }
                
                // Check for missing creationTime or lifespan
                if (particle.userData.creationTime === undefined || particle.userData.lifespan === undefined) {
                    scene.remove(particle);
                    smokeParticles.splice(i, 1);
                    continue;
                }
                
                const elapsed = (currentTime - particle.userData.creationTime) / 1000;
                
                if (elapsed < particle.userData.lifespan) {
                    // Ensure velocity exists before using it
                    if (!particle.userData.velocity) {
                        particle.userData.velocity = { x: 0, y: 0, z: 0 };
                    }
                    
                    // Update position based on velocity
                    particle.position.x += particle.userData.velocity.x * deltaTime;
                    particle.position.y += particle.userData.velocity.y * deltaTime;
                    particle.position.z += particle.userData.velocity.z * deltaTime;
                    
                    // Special handling for wood chunks from tree destruction
                    if (particle.userData.isWoodChunk) {
                        // Apply gravity
                        particle.userData.velocity.y -= gravity * deltaTime;
                        
                        // Apply rotation with proper rotation speed
                        if (particle.userData.rotationSpeed) {
                            particle.rotation.x += particle.userData.rotationSpeed.x * deltaTime * 10;
                            particle.rotation.y += particle.userData.rotationSpeed.y * deltaTime * 10;
                            particle.rotation.z += particle.userData.rotationSpeed.z * deltaTime * 10;
                        }
                        
                        // Check for collision with terrain
                        const terrainHeight = getTerrainHeightAt(particle.position.x, particle.position.z);
                        if (particle.position.y < terrainHeight) {
                            // Position just above terrain
                            particle.position.y = terrainHeight;
                            
                            // Bounce with energy loss
                            particle.userData.velocity.y = -particle.userData.velocity.y * 0.4;
                            
                            // Apply ground friction
                            particle.userData.velocity.x *= 0.7;
                            particle.userData.velocity.z *= 0.7;
                            
                            // If chunk has nearly stopped, make it come to rest
                            const horizontalSpeed = Math.sqrt(
                                particle.userData.velocity.x * particle.userData.velocity.x + 
                                particle.userData.velocity.z * particle.userData.velocity.z
                            );
                            
                            if (Math.abs(particle.userData.velocity.y) < 0.5 && horizontalSpeed < 0.5) {
                                particle.userData.velocity.x = 0;
                                particle.userData.velocity.y = 0;
                                particle.userData.velocity.z = 0;
                                
                                // Let chunks fade out when they come to rest
                                if (particle.material && !particle.userData.startedFading) {
                                    particle.userData.startedFading = true;
                                    particle.userData.fadeStartTime = Date.now();
                                    particle.userData.lifespan = Math.min(
                                        particle.userData.lifespan,
                                        elapsed + 1.5 // Additional 1.5 seconds to fade out
                                    );
                                }
                            }
                        }
                        
                        // Apply fading for wood chunks that have started fading
                        if (particle.material && particle.userData.startedFading) {
                            const fadeElapsed = (Date.now() - particle.userData.fadeStartTime) / 1000;
                            particle.material.opacity = Math.max(0, 1 - fadeElapsed / 1.5);
                        }
                    }
                    // Apply gravity to debris but not to smoke
                    else if (particle.geometry instanceof THREE.BoxGeometry) {
                        particle.userData.velocity.y -= gravity * deltaTime;
                        
                        // Check for rotation properties before applying
                        if (particle.userData.rotationSpeed) {
                            particle.rotation.x += particle.userData.rotationSpeed.x || 0;
                            particle.rotation.y += particle.userData.rotationSpeed.y || 0;
                            particle.rotation.z += particle.userData.rotationSpeed.z || 0;
                        }
                        
                        // Check for collision with terrain for debris
                        const terrainHeight = getTerrainHeightAt(particle.position.x, particle.position.z);
                        if (particle.position.y < terrainHeight) {
                            particle.position.y = terrainHeight;
                            particle.userData.velocity.y = -particle.userData.velocity.y * 0.3; // Bounce with damping
                            particle.userData.velocity.x *= 0.8; // Friction
                            particle.userData.velocity.z *= 0.8; // Friction
                        }
                    } else {
                        // Special handling for smoke ring particles
                        if (particle.userData.type === 'ring') {
                            // Ring particles expand outward more quickly
                            particle.userData.velocity.x *= 1.02;
                            particle.userData.velocity.y *= 1.02;
                            particle.userData.velocity.z *= 1.02;
                            
                            // Ring particles fade faster
                            if (particle.material) {
                                // More dramatic opacity fade for ring particles
                                const ringOpacity = 1 - (elapsed / particle.userData.lifespan) * 1.5;
                                particle.material.opacity = Math.max(0, ringOpacity);
                                
                                // Scale up slightly as they dissipate
                                const ringScale = 1 + elapsed * 0.8; // More expansion than regular smoke
                                particle.scale.set(ringScale, ringScale, ringScale);
                            }
                        } else {
                            // For regular smoke, gradually slow down
                            particle.userData.velocity.x *= 0.99;
                            particle.userData.velocity.y *= 0.99;
                            particle.userData.velocity.z *= 0.99;
                            
                            // For trail particles, fade out more quickly (ensure material exists)
                            if (particle.material && particle.geometry && particle.geometry.parameters && 
                                particle.geometry.parameters.radius < 0.1) {
                                if (particle.userData.fadeSpeed) {
                                    particle.material.opacity -= particle.userData.fadeSpeed;
                                } else {
                                    particle.material.opacity = Math.max(0, particle.material.opacity - 0.02);
                                }
                                
                                const scale = (particle.userData.scale || 1) * (1 - elapsed / particle.userData.lifespan);
                                particle.scale.set(scale, scale, scale);
                            } else if (particle.material) {
                                // Check for fadeDelay property
                                const fadeDelay = particle.userData.fadeDelay || 0;
                                
                                // Only start fading after the delay
                                if (elapsed > fadeDelay) {
                                    // Calculate fade factor based on remaining time after delay
                                    const fadeElapsed = elapsed - fadeDelay;
                                    const fadeDuration = particle.userData.lifespan - fadeDelay;
                                    const fadeFactor = Math.min(1, fadeElapsed / fadeDuration);
                                    
                                    // Apply a more gradual fade out for dense smoke
                                    if (particle.geometry.parameters.radius > 0.2) {
                                        // This is our dense smoke - fade more slowly
                                        particle.material.opacity = Math.max(0, particle.material.opacity - 0.005);
                                        
                                        // Gradually increase size of smoke for more dramatic effect
                                        const smokeScale = 1 + elapsed * 0.3;
                                        particle.scale.set(smokeScale, smokeScale, smokeScale);
                                    } else {
                                        // Regular smoke behavior
                                        particle.material.opacity = Math.max(0, particle.material.opacity - 0.01);
                                        
                                        // Gradually increase size of smoke
                                        const smokeScale = 1 + elapsed * 0.5;
                                        particle.scale.set(smokeScale, smokeScale, smokeScale);
                                    }
                                } else {
                                    // Before fadeDelay, slowly increase size without fading
                                    const earlyScale = 1 + elapsed * 0.2;
                                    particle.scale.set(earlyScale, earlyScale, earlyScale);
                                }
                            }
                        }
                    }
                } else {
                    // Remove expired particle
                    scene.remove(particle);
                    smokeParticles.splice(i, 1);
                }
            }
        }

        // New function to create a health bar for a tank
        function createHealthBar(tank) {
            // Create container group for health bar
            const healthBarGroup = new THREE.Group();
            healthBarGroup.name = "healthBar";
            
            // Create background bar (gray)
            const bgBarGeometry = new THREE.BoxGeometry(1.5, 0.15, 0.05);
            const bgBarMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
            const bgBar = new THREE.Mesh(bgBarGeometry, bgBarMaterial);
            // Center the background bar at origin
            bgBar.position.set(0, 0, 0);
            healthBarGroup.add(bgBar);
            
            // Create foreground bar (colored based on tank)
            const fgBarGeometry = new THREE.BoxGeometry(1.5, 0.15, 0.06);
            const barColor = tank.userData.isPlayer ? 0x00ff00 : 0xff3333; // Green for player, red for computer
            const fgBarMaterial = new THREE.MeshBasicMaterial({ color: barColor });
            const fgBar = new THREE.Mesh(fgBarGeometry, fgBarMaterial);
            fgBar.name = "healthFill";
            
            // Set the origin to left side for easier scaling
            // Instead of translating geometry, position both elements consistently
            fgBar.position.set(0, 0, 0.005); // Slightly in front of the background for visibility
            
            // Adjust geometry transformations for proper scaling from left edge
            fgBarGeometry.translate(0.75, 0, 0);
            bgBarGeometry.translate(0.75, 0, 0);
            
            healthBarGroup.add(fgBar);
            
            // Position health bar above tank
            healthBarGroup.position.set(0, 1.3, 0);
            
            // Add health bar to tank
            tank.add(healthBarGroup);
            tank.userData.healthBar = healthBarGroup;
            
            // Update health bar to show current health
            updateHealthBar(tank);
        }

        // New function to update health bar appearance
        function updateHealthBar(tank) {
            if (!tank || !tank.userData || !tank.userData.healthBar) return;
            
            const healthPercent = tank.userData.health / MAX_HEALTH;
            const healthFill = tank.userData.healthBar.getObjectByName("healthFill");
            
            if (healthFill) {
                // Scale health bar fill based on current health
                healthFill.scale.x = healthPercent;
                
                // Update color of health bar based on health percentage
                if (healthPercent > 0.6) {
                    // Healthy - green
                    healthFill.material.color.set(tank.userData.isPlayer ? 0x00ff00 : 0xff3333);
                } else if (healthPercent > 0.3) {
                    // Medium health - yellow/orange
                    healthFill.material.color.set(tank.userData.isPlayer ? 0xffff00 : 0xff7700);
                } else {
                    // Low health - red/critical
                    healthFill.material.color.set(tank.userData.isPlayer ? 0xff0000 : 0xff0000);
                }
            }
        }

        // Add updateUIHealthBars function
        function updateUIHealthBars() {
            // Update player health bar
            const playerHealthBar = document.getElementById('player-health-bar');
            const playerHealthText = document.getElementById('player-health-text');
            const playerHealthPercent = (playerTank.userData.health / MAX_HEALTH) * 100;
            
            if (playerHealthBar) {
                playerHealthBar.style.width = playerHealthPercent + '%';
                
                // Change color based on health level
                if (playerHealthPercent > 60) {
                    playerHealthBar.style.background = 'linear-gradient(to right, #00ff00, #007700)';
                } else if (playerHealthPercent > 30) {
                    playerHealthBar.style.background = 'linear-gradient(to right, #ffff00, #aaaa00)';
                } else {
                    playerHealthBar.style.background = 'linear-gradient(to right, #ff0000, #aa0000)';
                }
            }
            
            if (playerHealthText) {
                playerHealthText.textContent = Math.round(playerHealthPercent) + '%';
            }
            
            // Update computer health bar
            const computerHealthBar = document.getElementById('computer-health-bar');
            const computerHealthText = document.getElementById('computer-health-text');
            const computerHealthPercent = (computerTank.userData.health / MAX_HEALTH) * 100;
            
            if (computerHealthBar) {
                computerHealthBar.style.width = computerHealthPercent + '%';
                
                // Change color based on health level
                if (computerHealthPercent > 60) {
                    computerHealthBar.style.background = 'linear-gradient(to right, #ff3333, #aa0000)';
                } else if (computerHealthPercent > 30) {
                    computerHealthBar.style.background = 'linear-gradient(to right, #ff7700, #aa5500)';
                } else {
                    computerHealthBar.style.background = 'linear-gradient(to right, #ff0000, #aa0000)';
                }
            }
            
            if (computerHealthText) {
                computerHealthText.textContent = Math.round(computerHealthPercent) + '%';
            }
        }

        // Initialize powerups display when the game starts
        document.addEventListener('DOMContentLoaded', function() {
            updatePowerupsDisplay();
        });

        function updateCannons() {
            // Safety check - if any required object is missing, just return
            if (!playerTank || !computerTank || !playerTank.userData || !playerTank.userData.cannon) {
                return;
            }
            
            try {
                // Update player cannon based on angle slider and tank rotation
                const playerAngle = parseInt(document.getElementById('angle-control').value);
                const playerAngleRad = THREE.MathUtils.degToRad(playerAngle);
                
                // Set the cannon's rotation and position
                if (playerTank.userData && playerTank.userData.cannon) {
                    // Calculate the cannon's length (half the cylinder length since pivot is in center)
                    const cannonLength = 0.6; // Half of the 1.2 total length
                    
                    // Set base position for the cannon pivot point (at the turret)
                    const baseX = 0.4;
                    const baseY = 0.4;
                    const baseZ = 0;
                    
                    // Calculate offset needed to keep the cannon's base at the pivot point
                    // This is the key to making it rotate from the end rather than the center
                    const offsetX = cannonLength * Math.cos(playerAngleRad);
                    const offsetY = cannonLength * Math.sin(playerAngleRad);
                    
                    // Apply rotation (add PI/2 to account for the initial 90-degree rotation)
                    playerTank.userData.cannon.rotation.z = Math.PI / 2 + playerAngleRad;
                    
                    // Position cannon with the calculated offset to simulate pivot from base
                    playerTank.userData.cannon.position.set(
                        baseX + offsetX,
                        baseY + offsetY,
                        baseZ
                    );
                }
                
                // For computer tank
                if (computerTank && computerTank.userData && computerTank.userData.cannon) {
                    // If it's the computer's turn, adjust aim toward player
                    let computerAngle = 20; // Default angle
                    
                    if (!playerTurn && playerTank && playerTank.position && computerTank.position) {
                        // Calculate horizontal direction and distance to player
                        const toPlayer = playerTank.position.clone().sub(computerTank.position);
                        const horizontalDist = Math.sqrt(toPlayer.x * toPlayer.x + toPlayer.z * toPlayer.z);
                        
                        // Calculate vertical angle needed (simple ballistic math)
                        const heightDiff = playerTank.position.y - computerTank.position.y;
                        const gravity = 9.8;
                        const power = document.getElementById('power-control').value / 5;
                        
                        // Calculate angle for a ballistic trajectory
                        computerAngle = calculateFiringAngle(horizontalDist, heightDiff, power, gravity);
                        
                        // Ensure we have a valid angle
                        if (isNaN(computerAngle) || computerAngle < 0) {
                            computerAngle = 30; // Fallback angle if calculation fails
                        }
                        
                        // Clamp angle between 0 and 90 degrees
                        computerAngle = Math.max(0, Math.min(90, computerAngle));
                    }
                    
                    // Convert to radians
                    const computerAngleRad = THREE.MathUtils.degToRad(computerAngle);
                    
                    // Calculate the cannon's length (half the cylinder length since pivot is in center)
                    const cannonLength = 0.6; // Half of the 1.2 total length
                    
                    // Set base position for the cannon pivot point (at the turret)
                    const baseX = -1.3;
                    const baseY = .8;
                    const baseZ = 0;
                    
                    // For computer tank, angles work in the opposite direction
                    // Use negative angle for position calculation to match the rotation
                    const offsetX = cannonLength * Math.cos(-computerAngleRad);
                    const offsetY = cannonLength * Math.sin(-computerAngleRad);
                    
                    // Apply rotation (add PI/2 to account for the initial 90-degree rotation)
                    // Add PI (180 degrees) because computer tank faces opposite direction
                    // Subtract the angle for the computer tank (rather than adding it)
                    computerTank.userData.cannon.rotation.z = Math.PI / 2 + Math.PI - computerAngleRad;
                    
                    // Position cannon with the calculated offset
                    computerTank.userData.cannon.position.set(
                        baseX + offsetX,
                        baseY + offsetY,
                        baseZ
                    );
                }
            } catch (error) {
                console.error("Error in updateCannons:", error);
                // Continue gracefully
            }
        }

        // Helper function to calculate firing angle
        function calculateFiringAngle(distance, heightDifference, velocity, gravity) {
            // Calculate the angle required to hit a target at the given distance and height difference
            // Using the projectile motion equation
            const v2 = velocity * velocity;
            const term = v2 * v2 - gravity * (gravity * distance * distance + 2 * heightDifference * v2);
            
            if (term < 0) {
                // No solution exists (target is too far for given velocity)
                return 45; // Return a reasonable default
            }
            
            // Calculate the two possible angles
            const angle1 = Math.atan((v2 + Math.sqrt(term)) / (gravity * distance));
            const angle2 = Math.atan((v2 - Math.sqrt(term)) / (gravity * distance));
            
            // Convert from radians to degrees
            const angleDeg1 = THREE.MathUtils.radToDeg(angle1);
            const angleDeg2 = THREE.MathUtils.radToDeg(angle2);
            
            // Choose the lower angle if valid, otherwise use the higher one
            return (angleDeg1 > 0 && angleDeg1 < 90) ? angleDeg1 : angleDeg2;
        }

        function updateTankPositions() {
            // Safety check - if any required object is missing, just return
            if (!playerTank || !computerTank || !terrain) {
                return;
            }
            
            // Check if the playerTank and its position exist
            if (playerTank && playerTank.position && terrain) {
                // Apply gravity to make tanks follow terrain
                const deltaTime = 1/60; // Fixed time step
                applyTankGravity(playerTank, deltaTime);
                
                // Cannon position is handled in updateCannons to maintain the proper pivot point
            }
            
            // Check if the computerTank and its position exist
            if (computerTank && computerTank.position && terrain) {
                // Apply gravity to computer tank
                const deltaTime = 1/60; // Fixed time step
                applyTankGravity(computerTank, deltaTime);
                
                // Cannon position is handled in updateCannons to maintain the proper pivot point
            }
        }

        function computerTakeTurn() {
            if (!playerTurn && playerTank && computerTank) {
                // Calculate vector from computer to player
                const toPlayer = new THREE.Vector3(
                    playerTank.position.x - computerTank.position.x,
                    0, // Ignore height difference for horizontal angle
                    playerTank.position.z - computerTank.position.z
                );
                
                // Calculate horizontal angle to player (in radians)
                const horizontalAngle = Math.atan2(toPlayer.z, toPlayer.x);
                
                // Rotate computer tank to face the player
                computerTank.rotation.y = horizontalAngle - Math.PI; // Subtract PI to face toward player
                
                // Calculate horizontal distance for the vertical angle calculation
                const horizontalDist = Math.sqrt(toPlayer.x * toPlayer.x + toPlayer.z * toPlayer.z);
                
                // Add a small random offset to make computer less perfect
                const distance = horizontalDist * (1 + (Math.random() * 0.1 - 0.05)); // ±5% variation
                
                // Calculate height difference
                const heightDiff = playerTank.position.y - computerTank.position.y;
                
                // Pick a random power level between 50-90%
                const power = 50 + Math.floor(Math.random() * 40);
                document.getElementById('power-control').value = power;
                document.getElementById('power-value').textContent = power;
                
                // Calculate firing angle
                const scaledPower = power / 5; // match the scaling in fireCannon
                const calculatedAngle = calculateFiringAngle(distance, heightDiff, scaledPower, 9.8);
                
                // Make sure we have a valid angle (fallback to 45 degrees if calculation fails)
                const finalAngle = (isNaN(calculatedAngle) || calculatedAngle < 0 || calculatedAngle > 90) ? 
                    45 : calculatedAngle;
                
                // Set angle slider and value
                document.getElementById('angle-control').value = finalAngle;
                document.getElementById('angle-value').textContent = finalAngle + '°';
                
                // Delay firing to make the game feel more natural
                setTimeout(() => {
                    fireCannon();
                }, 1500);
            }
        }

        function createEnvironmentObjects() {
            // Create trees and boulders scattered around the terrain
            
            // Define no-go zones around tanks to ensure they don't get blocked
            const safeZoneRadius = 4;
            const playerSafeZone = new THREE.Vector2(-12, 0); // Player tank position
            const computerSafeZone = new THREE.Vector2(12, 0); // Computer tank position
            
            // Randomize the number of boulders and trees for each game
            const numBoulders = 12 + Math.floor(Math.random() * 10); // 12-21 boulders
            const numTrees = 15 + Math.floor(Math.random() * 12);    // 15-26 trees
            
            // 1. Create boulders
            for (let i = 0; i < numBoulders; i++) {
                // Random position on the terrain
                let x, z;
                let tooClose = true;
                
                // Keep trying positions until we find one that's not too close to tanks
                while (tooClose) {
                    x = (Math.random() * 44) - 22; // Range from -22 to 22 (updated for wider terrain)
                    z = (Math.random() * 14) - 7;  // Range from -7 to 7
                    
                    // Check distance from tanks
                    const distToPlayer = new THREE.Vector2(x, z).distanceTo(playerSafeZone);
                    const distToComputer = new THREE.Vector2(x, z).distanceTo(computerSafeZone);
                    
                    // Only place if outside both safe zones and not on the central hill (x close to 0)
                    tooClose = (distToPlayer < safeZoneRadius || distToComputer < safeZoneRadius || Math.abs(x) < 2);
                    
                    // Also avoid central firing line
                    if (Math.abs(z) < 1.5) tooClose = true;
                }
                
                // Get the height at this position
                const y = getTerrainHeightAt(x, z);
                
                // Create boulder with random size and rotation
                const size = 0.3 + Math.random() * 0.7; // Size between 0.3 and 1.0
                
                // Use a combination of geometries for varied boulders - only geometric shapes (no spheres)
                let boulderGeometry;
                const boulderType = Math.floor(Math.random() * 3);
                
                if (boulderType === 0) {
                    // Rough boulder - icosahedron
                    boulderGeometry = new THREE.IcosahedronGeometry(size, 0);
                    // Add some randomization to vertices for more variation
                    const vertices = boulderGeometry.attributes.position.array;
                    for (let j = 0; j < vertices.length; j += 3) {
                        vertices[j] += (Math.random() - 0.5) * 0.15 * size;
                        vertices[j+1] += (Math.random() - 0.5) * 0.15 * size;
                        vertices[j+2] += (Math.random() - 0.5) * 0.15 * size;
                    }
                    boulderGeometry.attributes.position.needsUpdate = true;
                    boulderGeometry.computeVertexNormals();
                } else if (boulderType === 1) {
                    // Angular boulder - dodecahedron
                    boulderGeometry = new THREE.DodecahedronGeometry(size, 0);
                    // Add some randomization to vertices for more variation
                    const vertices = boulderGeometry.attributes.position.array;
                    for (let j = 0; j < vertices.length; j += 3) {
                        vertices[j] += (Math.random() - 0.5) * 0.12 * size;
                        vertices[j+1] += (Math.random() - 0.5) * 0.12 * size;
                        vertices[j+2] += (Math.random() - 0.5) * 0.12 * size;
                    }
                    boulderGeometry.attributes.position.needsUpdate = true;
                    boulderGeometry.computeVertexNormals();
                } else {
                    // Octahedron - another geometric shape option
                    boulderGeometry = new THREE.OctahedronGeometry(size, 0);
                    // Add some randomization to vertices for more variation
                    const vertices = boulderGeometry.attributes.position.array;
                    for (let j = 0; j < vertices.length; j += 3) {
                        vertices[j] += (Math.random() - 0.5) * 0.18 * size;
                        vertices[j+1] += (Math.random() - 0.5) * 0.18 * size;
                        vertices[j+2] += (Math.random() - 0.5) * 0.18 * size;
                    }
                    boulderGeometry.attributes.position.needsUpdate = true;
                    boulderGeometry.computeVertexNormals();
                }
                
                // Create boulder material - gray with slight variation
                const grayness = 0.4 + Math.random() * 0.3; // 0.4 to 0.7
                const boulderMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(grayness, grayness, grayness),
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const boulder = new THREE.Mesh(boulderGeometry, boulderMaterial);
                
                // Position boulder on terrain
                boulder.position.set(x, y, z);
                
                // Random rotation
                boulder.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                boulder.castShadow = true;
                boulder.receiveShadow = true;
                boulder.name = "boulder" + i;
                scene.add(boulder);
            }
            
            // 2. Create trees
            for (let i = 0; i < numTrees; i++) {
                // Random position on the terrain
                let x, z;
                let tooClose = true;
                
                // Keep trying positions until we find one that's not too close to tanks
                while (tooClose) {
                    x = (Math.random() * 44) - 22; // Range from -22 to 22 (updated for wider terrain)
                    z = (Math.random() * 14) - 7;  // Range from -7 to 7
                    
                    // Check distance from tanks
                    const distToPlayer = new THREE.Vector2(x, z).distanceTo(playerSafeZone);
                    const distToComputer = new THREE.Vector2(x, z).distanceTo(computerSafeZone);
                    
                    // Only place if outside both safe zones and not on the central hill (x close to 0)
                    tooClose = (distToPlayer < safeZoneRadius || distToComputer < safeZoneRadius || Math.abs(x) < 2);
                    
                    // Also avoid central firing line
                    if (Math.abs(z) < 1.5) tooClose = true;
                }
                
                // Get the height at this position
                const y = getTerrainHeightAt(x, z);
                
                // Create tree group
                const tree = new THREE.Group();
                
                // Create tree trunk
                const height = 1.5 + Math.random() * 1.0; // Height between 1.5 and 2.5
                const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, height, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513, // Brown color for trunk
                    roughness: 0.9,
                    metalness: 0.0
                });
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = height / 2; // Position trunk so its base is at y=0
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);
                
                // Create tree foliage (different types for variety)
                const treeType = Math.floor(Math.random() * 3);
                let foliageGeometry;
                
                if (treeType === 0) {
                    // Pine tree - cone shape
                    foliageGeometry = new THREE.ConeGeometry(0.7, 1.2, 8);
                    
                    // Position first cone
                    const foliageMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2E8B57, // Dark green
                        roughness: 0.8,
                        metalness: 0.0
                    });
                    
                    const foliage1 = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage1.position.y = height - 0.3;
                    foliage1.castShadow = true;
                    tree.add(foliage1);
                    
                    // Add a second smaller cone on top
                    const foliage2 = new THREE.Mesh(
                        new THREE.ConeGeometry(0.5, 0.9, 8),
                        foliageMaterial
                    );
                    foliage2.position.y = height + 0.4;
                    foliage2.castShadow = true;
                    tree.add(foliage2);
                    
                } else if (treeType === 1) {
                    // Deciduous tree - sphere
                    foliageGeometry = new THREE.SphereGeometry(0.8, 8, 6);
                    
                    const foliageMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x3a9d23, // Brighter green
                        roughness: 0.8,
                        metalness: 0.0
                    });
                    
                    // Position main foliage
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.y = height + 0.2;
                    foliage.scale.y = 1.2; // Stretch slightly vertically
                    foliage.castShadow = true;
                    tree.add(foliage);
                    
                } else {
                    // Oak-like tree - multiple spheres
                    const foliageMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4a7e2a, // Medium green
                        roughness: 0.8,
                        metalness: 0.0
                    });
                    
                    // Create 3-4 overlapping spheres for a fuller canopy
                    const numSpheres = 3 + Math.floor(Math.random() * 2);
                    
                    for (let j = 0; j < numSpheres; j++) {
                        const sphereSize = 0.5 + Math.random() * 0.3;
                        const foliage = new THREE.Mesh(
                            new THREE.SphereGeometry(sphereSize, 8, 6),
                            foliageMaterial
                        );
                        
                        // Position with slight variation
                        foliage.position.y = height + 0.1;
                        foliage.position.x = (Math.random() - 0.5) * 0.5;
                        foliage.position.z = (Math.random() - 0.5) * 0.5;
                        foliage.castShadow = true;
                        tree.add(foliage);
                    }
                }
                
                // Add subtle random rotation for more natural look
                tree.rotation.y = Math.random() * Math.PI * 2;
                tree.rotation.x = (Math.random() - 0.5) * 0.1; // Slight tilt
                tree.rotation.z = (Math.random() - 0.5) * 0.1; // Slight tilt
                
                // Position tree on terrain
                tree.position.set(x, y, z);
                tree.name = "tree" + i;
                scene.add(tree);
            }
        }

        function checkEnvironmentCollision() {
            if (!cannonball) return;
            
            // Check for collisions with boulders
            for (let i = 0; i < scene.children.length; i++) {
                const object = scene.children[i];
                
                // Check if this is a boulder
                if (object.name && object.name.startsWith("boulder")) {
                    const distance = cannonball.position.distanceTo(object.position);
                    
                    // Boulder collision radius depends on boulder size
                    // We don't have direct access to the boulder's scale, so we approximate using a bounding sphere
                    const boundingSphere = new THREE.Sphere();
                    const boundingBox = new THREE.Box3().setFromObject(object);
                    boundingBox.getBoundingSphere(boundingSphere);
                    
                    // Add a small buffer to make collision detection more reliable
                    const collisionRadius = boundingSphere.radius + 0.2;
                    
                    if (distance < collisionRadius) {
                        // Hard collision with boulder - create small explosion and bounce
                        createExplosion(cannonball.position.clone());
                        
                        // Play rock impact sound (if you add sound later)
                        
                        // Calculate reflection vector for realistic bounce
                        const normal = new THREE.Vector3()
                            .subVectors(cannonball.position, object.position)
                            .normalize();
                            
                        // V' = V - 2(V·N)N where N is normalized
                        const dot = cannonballVelocity.x * normal.x + 
                                   cannonballVelocity.y * normal.y + 
                                   cannonballVelocity.z * normal.z;
                                   
                        cannonballVelocity.x = (cannonballVelocity.x - 2 * dot * normal.x) * 0.5; // 50% energy loss
                        cannonballVelocity.y = (cannonballVelocity.y - 2 * dot * normal.y) * 0.5;
                        cannonballVelocity.z = (cannonballVelocity.z - 2 * dot * normal.z) * 0.5;
                        
                        // Move the cannonball slightly away from the boulder to prevent getting stuck
                        cannonball.position.x += normal.x * 0.3;
                        cannonball.position.y += normal.y * 0.3;
                        cannonball.position.z += normal.z * 0.3;
                        
                        // Add debris effect
                        for (let j = 0; j < 5; j++) {
                            const debrisGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
                            const debrisMaterial = new THREE.MeshStandardMaterial({
                                color: 0x888888,
                                roughness: 0.9,
                                metalness: 0.1
                            });
                            
                            const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                            debris.position.copy(cannonball.position);
                            
                            // Random direction away from impact
                            const debrisVelocity = new THREE.Vector3(
                                (Math.random() - 0.5) * 3,
                                Math.random() * 3 + 1,
                                (Math.random() - 0.5) * 3
                            );
                            
                            debris.userData = {
                                velocity: debrisVelocity,
                                lifespan: 1 + Math.random(),
                                creationTime: Date.now()
                            };
                            
                            scene.add(debris);
                            smokeParticles.push(debris);
                        }
                        
                        return; // Exit after handling one collision
                    }
                }
                
                // Check if this is a tree
                else if (object.name && object.name.startsWith("tree")) {
                    const distance = cannonball.position.distanceTo(object.position);
                    
                    // Tree collision - slightly larger radius since trees are bigger
                    if (distance < 0.8) {
                        // Create a small explosion at the impact point
                        createExplosion(cannonball.position.clone(), 0.7, 0.5, 0xffaa00); // Smaller, shorter explosion with orange color
                        
                        // Create wood chunks and debris
                        createTreeDestructionEffect(object, cannonball.position.clone());
                        
                        // Camera shake to emphasize impact
                        cameraShake(0.3, 300, false);
                        
                        // Remove the tree from the scene
                        scene.remove(object);
                        
                        // Create leaves/branch effect - more leaves since the tree is being destroyed
                        for (let j = 0; j < 20; j++) {
                            const leafGeometry = new THREE.PlaneGeometry(0.1, 0.1);
                            const leafMaterial = new THREE.MeshBasicMaterial({
                                color: 0x226622,
                                transparent: true,
                                opacity: 0.7,
                                side: THREE.DoubleSide
                            });
                            
                            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                            leaf.position.copy(object.position);
                            leaf.position.y += Math.random() * 1.5; // Leaves come from throughout the tree height
                            
                            // Random rotation for leaves
                            leaf.rotation.set(
                                Math.random() * Math.PI,
                                Math.random() * Math.PI,
                                Math.random() * Math.PI
                            );
                            
                            // Random direction with more upward velocity for explosion effect
                            const leafVelocity = new THREE.Vector3(
                                (Math.random() - 0.5) * 3,
                                Math.random() * 2 + 1,  // More upward initial velocity
                                (Math.random() - 0.5) * 3
                            );
                            
                            leaf.userData = {
                                velocity: leafVelocity,
                                rotationSpeed: new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.1,
                                    (Math.random() - 0.5) * 0.1,
                                    (Math.random() - 0.5) * 0.1
                                ),
                                lifespan: 2 + Math.random(),
                                creationTime: Date.now()
                            };
                            
                            scene.add(leaf);
                            smokeParticles.push(leaf);
                        }
                        
                        // Slow down cannonball
                        cannonballVelocity.x *= 0.6;
                        cannonballVelocity.z *= 0.6;
                        
                        // Add slight random deflection
                        cannonballVelocity.x += (Math.random() - 0.5) * 0.5;
                        cannonballVelocity.z += (Math.random() - 0.5) * 0.5;
                        
                        return; // Exit after handling one collision
                    }
                }
            }
        }

        // New function to force shadow map update
        function forceShadowMapUpdate() {
            // Find the directional light
            const mainLight = scene.children.find(child => 
                child instanceof THREE.DirectionalLight && child.castShadow);
            
            if (mainLight) {
                // Force shadow map update
                mainLight.shadow.needsUpdate = true;
                
                // Set a helper target for the light to aim better at the terrain
                const target = new THREE.Object3D();
                target.position.set(0, 0, 0); // Center of the scene
                scene.add(target);
                mainLight.target = target;
                
                // Ensure the directional light is updated
                mainLight.updateMatrixWorld();
                mainLight.target.updateMatrixWorld();
                
                // Render the scene once to update shadow maps
                renderer.render(scene, camera);
                
                // Render once more to make sure shadows are fully applied
                requestAnimationFrame(() => {
                    renderer.render(scene, camera);
                });
            }
        }

        // Function to update shadows during gameplay
        function updateShadows() {
            // Find all shadow-casting lights
            scene.traverse(function(object) {
                if (object instanceof THREE.Light && object.castShadow) {
                    object.shadow.needsUpdate = true;
                    
                    // Make sure light targets are updated
                    if (object.target) {
                        object.target.updateMatrixWorld();
                        object.updateMatrixWorld();
                    }
                }
            });
            
            // Update terrain shadow casting
            if (terrain) {
                // Force terrain matrix update to update shadow casting
                terrain.updateMatrixWorld(true);
            }
        }

        // Function to create the tree destruction effect
        function createTreeDestructionEffect(tree, impactPoint) {
            // Get tree position as base
            const treePosition = tree.position.clone();
            
            // Create wood chunks
            const chunkCount = 12; // Number of wood chunks
            const woodColor = 0x8B4513; // Brown color for wood
            
            for (let i = 0; i < chunkCount; i++) {
                // Create wood chunk with randomized size
                const size = 0.05 + Math.random() * 0.1;
                const height = 0.1 + Math.random() * 0.3; // Longer in one dimension for log-like pieces
                
                // Different geometries for variety: some rectangular chunks, some cylindrical
                let chunkGeometry;
                if (Math.random() > 0.5) {
                    chunkGeometry = new THREE.BoxGeometry(size, height, size);
                } else {
                    chunkGeometry = new THREE.CylinderGeometry(size/2, size/2, height, 6, 1);
                    // Rotate cylinder to be horizontal
                    if (Math.random() > 0.5) {
                        chunkGeometry.rotateX(Math.PI/2);
                    } else {
                        chunkGeometry.rotateZ(Math.PI/2);
                    }
                }
                
                const woodMaterial = new THREE.MeshStandardMaterial({
                    color: woodColor,
                    roughness: 0.8,
                    metalness: 0.1
                });
                
                const chunk = new THREE.Mesh(chunkGeometry, woodMaterial);
                
                // Position chunks throughout the tree's volume
                chunk.position.set(
                    treePosition.x + (Math.random() - 0.5) * 0.5,
                    treePosition.y + Math.random() * 1.2, // Different heights throughout tree
                    treePosition.z + (Math.random() - 0.5) * 0.5
                );
                
                // Calculate vector from impact point to the chunk for realistic explosion
                const directionFromImpact = new THREE.Vector3()
                    .subVectors(chunk.position, impactPoint)
                    .normalize();
                
                // Add some randomness and ensure upward component
                const explosionPower = 2 + Math.random() * 3;
                
                chunk.userData = {
                    velocity: new THREE.Vector3(
                        directionFromImpact.x * explosionPower + (Math.random() - 0.5) * 1.5,
                        directionFromImpact.y * explosionPower + Math.random() * 2, // Add upward velocity
                        directionFromImpact.z * explosionPower + (Math.random() - 0.5) * 1.5
                    ),
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.2,
                        y: (Math.random() - 0.5) * 0.2,
                        z: (Math.random() - 0.5) * 0.2
                    },
                    lifespan: 2 + Math.random() * 2, // Chunks stay a bit longer than leaves
                    creationTime: Date.now(),
                    isWoodChunk: true // Flag for special handling in updateParticles
                };
                
                scene.add(chunk);
                smokeParticles.push(chunk);
            }
            
            // Create dust/smoke at the base of the tree
            const smokeColor = 0xCCBB99; // Dusty color
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const smokeGeometry = new THREE.SphereGeometry(0.15 + Math.random() * 0.2, 8, 8);
                    const smokeMaterial = new THREE.MeshBasicMaterial({
                        color: smokeColor,
                        transparent: true,
                        opacity: 0.6 + Math.random() * 0.2
                    });
                    
                    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                    
                    // Position at base of tree with slight variation
                    smoke.position.set(
                        treePosition.x + (Math.random() - 0.5) * 0.4,
                        treePosition.y + Math.random() * 0.3, // Low to the ground
                        treePosition.z + (Math.random() - 0.5) * 0.4
                    );
                    
                    // Set properties for dust cloud
                    smoke.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.3, // Slow drift
                            0.3 + Math.random() * 0.5,   // Rise upward
                            (Math.random() - 0.5) * 0.3  // Slow drift
                        ),
                        rotationSpeed: (Math.random() - 0.5) * 0.02,
                        lifespan: 1.5 + Math.random() * 1, // Shorter lifespan
                        creationTime: Date.now(),
                        fadeDelay: 0.5 // Start fading after 0.5 seconds
                    };
                    
                    scene.add(smoke);
                    smokeParticles.push(smoke);
                }, i * 50); // Staggered creation for better effect
            }
        }
    </script>
</body>
</html> 